<!DOCTYPE html>
<html i18n-values="
  dir:textdirection;
  bookmarkbarattached:bookmarkbarattached;
  hasattribution:hasattribution;
  anim:anim;
  syncispresent:syncispresent;
  customlogo:customlogo"
  install-animation-enabled="true">
<head>
<meta charset="utf-8">
<title i18n-content="title"></title>
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The global object.
 * @type {!Object}
 */
const global = this;

// TODO(estade): This should be removed and calls replaced with cr.isMac
const IS_MAC = /^Mac/.test(navigator.platform);

/**
 * Alias for document.getElementById.
 * @param {string} id The ID of the element to find.
 * @return {HTMLElement} The found element or null if not found.
 */
function $(id) {
  return document.getElementById(id);
}

/**
 * Calls chrome.send with a callback and restores the original afterwards.
 * @param {string} name The name of the message to send.
 * @param {!Array} params The parameters to send.
 * @param {string} callbackName The name of the function that the backend calls.
 * @param {!Function} The function to call.
 */
function chromeSend(name, params, callbackName, callback) {
  var old = global[callbackName];
  global[callbackName] = function() {
    // restore
    global[callbackName] = old;

    var args = Array.prototype.slice.call(arguments);
    return callback.apply(global, args);
  };
  chrome.send(name, params);
}

/**
 * Generates a CSS url string.
 * @param {string} s The URL to generate the CSS url for.
 * @return {string} The CSS url string.
 */
function url(s) {
  // http://www.w3.org/TR/css3-values/#uris
  // Parentheses, commas, whitespace characters, single quotes (') and double
  // quotes (") appearing in a URI must be escaped with a backslash
  var s2 = s.replace(/(\(|\)|\,|\s|\'|\"|\\)/g, '\\$1');
  // WebKit has a bug when it comes to URLs that end with \
  // https://bugs.webkit.org/show_bug.cgi?id=28885
  if (/\\\\$/.test(s2)) {
    // Add a space to work around the WebKit bug.
    s2 += ' ';
  }
  return 'url("' + s2 + '")';
}

/**
 * Parses query parameters from Location.
 * @param {string} s The URL to generate the CSS url for.
 * @return {object} Dictionary containing name value pairs for URL
 */
function parseQueryParams(location) {
  var params = {};
  var query = unescape(location.search.substring(1));
  var vars = query.split("&");
  for (var i=0; i < vars.length; i++) {
    var pair = vars[i].split("=");
    params[pair[0]] = pair[1];
  }
  return params;
}

function findAncestorByClass(el, className) {
  return findAncestor(el, function(el) {
    if (el.classList)
      return el.classList.contains(className);
    return null;
  });
}

/**
 * Return the first ancestor for which the {@code predicate} returns true.
 * @param {Node} node The node to check.
 * @param {function(Node) : boolean} predicate The function that tests the
 *     nodes.
 * @return {Node} The found ancestor or null if not found.
 */
function findAncestor(node, predicate) {
  var last = false;
  while (node != null && !(last = predicate(node))) {
    node = node.parentNode;
  }
  return last ? node : null;
}

function swapDomNodes(a, b) {
  var afterA = a.nextSibling;
  if (afterA == b) {
    swapDomNodes(b, a);
    return;
  }
  var aParent = a.parentNode;
  b.parentNode.replaceChild(a, b);
  aParent.insertBefore(b, afterA);
}

// Handle click on a link. If the link points to a chrome: or file: url, then
// call into the browser to do the navigation.
document.addEventListener('click', function(e) {
  // Allow preventDefault to work.
  if (!e.returnValue)
    return;

  var el = e.target;
  if (el.nodeType == Node.ELEMENT_NODE &&
      el.webkitMatchesSelector('A, A *')) {
    while (el.tagName != 'A') {
      el = el.parentElement;
    }

    if ((el.protocol == 'file:' || el.protocol == 'about:') &&
        (e.button == 0 || e.button == 1)) {
      chrome.send('navigateToUrl', [
        el.href,
        el.target,
        e.button,
        e.altKey,
        e.ctrlKey,
        e.metaKey,
        e.shiftKey
      ]);
      e.preventDefault();
    }
  }
});
</script>
<script>
// Logging info for benchmarking purposes.
var log = [];
function logEvent(name, shouldLogTime) {
  if (shouldLogTime) {
    chrome.send('logEventTime', [name]);
  }
  log.push([name, Date.now()]);
}
logEvent('Tab.NewTabScriptStart', true);

/**
 * Registers a callback function so that if the backend calls it too early it
 * will get delayed until DOMContentLoaded is fired.
 * @param {string} name The name of the global function that the backend calls.
 */
function registerCallback(name) {
  var f = function(var_args) {
    var args = Array.prototype.slice.call(arguments);
    // If we still have the temporary function we delay until the dom is ready.
    if (global[name] == f) {
      logEvent(name + ' is not yet ready. Waiting for DOMContentLoaded');
      document.addEventListener('DOMContentLoaded', function() {
        logEvent('Calling the new ' + name);
        global[name].apply(null, args);
      });
    }
  };
  global[name] = f;
}

registerCallback('setMostVisitedPages');
registerCallback('recentlyClosedTabs');
registerCallback('syncMessageChanged');
registerCallback('getAppsCallback');
registerCallback('setShownSections');
registerCallback('foreignSessions');
registerCallback('bookmarkBarDetached');
registerCallback('bookmarkBarAttached');

chrome.send('getMostVisited');
chrome.send('getRecentlyClosedTabs');
chrome.send('getForeignSessions');
chrome.send('getApps');

</script>
<script>var templateData = {"anim":"true","appcreateshortcut":"Create shortcut","applaunchtypefullscreen":"Open full screen","applaunchtypepinned":"Open as pinned tab","applaunchtyperegular":"Open as regular tab","applaunchtypewindow":"Open as window","appoptions":"Options","apps":"Apps","appsettings":"Settings","appuninstall":"Uninstall","attributionintro":"Theme created by","bookmarkbarattached":"false","close":"Close","closedwindowmultiple":"$1 Tabs","closedwindowsingle":"1 Tab","closefirstrunnotification":"Close","customlogo":"false","downloads":"Downloads","fontfamily":"Helvetica, sans-serif","fontsize":"84%","foreignsessions":"Foreign Sessions","hasattribution":"true","help":"Help","helpurl":"https://www.google.com/support/chrome/?hl=en-US","history":"History","mostvisited":"Most visited","pagedisplaytooltip":"Change page layout","pinthumbnailtooltip":"Keep on this page","recentlyclosed":"Recently closed","removethumbnailtooltip":"Don't show on this page","restorethumbnails":"Restore all removed thumbnails","showhidelisttooltip":"List view","showhidethumbnailtooltip":"Thumbnail view","shown_sections":1,"syncispresent":"true","syncpromotext":"Set Up Sync...","textdirection":"ltr","thumbnailremovednotification":"Thumbnail removed.","title":"New Tab","undothumbnailremove":"Undo","unpinthumbnailtooltip":"Don't keep on this page","web_store_title":"Web Store","web_store_url":"https://chrome.google.com/webstore?hl=en-US"};</script>
<style>html {
  /* This is needed because of chrome://theme/css/new_tab.css */
  height: 100%;
}

body {
  margin: 0;
  height: 100%;
  overflow: auto;
  -webkit-user-select: none;
  cursor: default;
}

html[mode=app-launcher] {
  height: auto;
}

#main {
  box-sizing: border-box;
  -webkit-transition: width .15s;
  margin: 0 auto;
  min-height: 100%;
}

body.loading #main {
  /* We start out hidden to prevent glitchiness as the app and most visited
  data flows in. */
  visibility: hidden;
}

#main,
.section,
.maxiview,
#login-container,
#notification-container,
#closed-sections-bar {
  width: 920px;
}

html[dir=rtl] #main {
  background-position-x: 100%;
}

html[mode=app-launcher] #main {
  min-height: 50px;
}

html[anim=false] *,
.no-anim, .no-anim *,
.loading * {
  -webkit-transition: none !important;
  -webkit-animation: none !important;
}

:link,
:visited,
.link {
  cursor: pointer;
  text-decoration: underline;
  color: hsla(213, 90%, 24%, 0.33333);
  -webkit-appearance: none;
  border: 0;
  background: none;
}

.link-color {
  color: hsl(213, 90%, 24%);
  text-decoration: none;
}

.hide {
  opacity: 0 !important;
  visibility: hidden !important;
  pointer-events: none;
}

/* Notification */

#notification-container {
  position: fixed;
}

#notification {
  -webkit-transition: opacity .15s;
  position: relative;
  background-color: hsl(52, 100%, 80%);
  border: 1px solid rgb(211, 211, 211);
  border-radius: 6px;
  color: black;
  display: -webkit-box;
  font-weight: bold;
  margin: 2px auto;
  opacity: 0;
  padding: 7px 15px;
  pointer-events: none;
  white-space: nowrap;
  width: intrinsic;
  z-index: 2;
}

#notification.first-run {
  padding: 5px 13px; /* subtract the border width */
  border: 2px solid hsl(213, 55%, 75%);
  background-color: hsl(213, 63%, 93%);
  -webkit-box-shadow: 2px 2px 3px hsla(0, 0%, 0%, .3);
  font-weight: normal;
}

#notification.promo {
  padding: 5px 13px; /* subtract the border width */
  border: 1px solid hsl(0, 0%, 80%);
  background-color: hsl(120, 93%, 93%);
  -webkit-box-shadow: 2px 2px 3px hsla(0, 0%, 0%, .3);
  font-weight: normal;
}

#notification.promo a {
  color: rgb(0, 102, 204);
}

#notification-close {
  display: inline-block;
  border: 0;
  -webkit-margin-start: 10px;
  -webkit-margin-end: auto;
  vertical-align: middle;
  width: 16px;
  height: 16px;
  background: no-repeat;
  background-color: transparent;
  background-image: url('chrome://theme/IDR_CLOSE_BAR');
  padding: 0;
}

#notification-close:hover,
#notification-close:focus {
  background-image: url('chrome://theme/IDR_CLOSE_BAR_H');
}

#notification-close:active {
  background-image: url('chrome://theme/IDR_CLOSE_BAR_P');
}

#notification > * {
  max-width: 500px;
  overflow: hidden;
  text-overflow: ellipsis;
}

#notification.first-run > * {
  white-space: normal;
}

#notification.show {
  opacity: 1;
  pointer-events: all;
  -webkit-transition: opacity 1s;
}

#notification .link {
  color: rgba(0, 102, 204, 0.3);
  -webkit-padding-start: 20px;
}

#notification .link-color {
  color: rgb(0, 102, 204);
}

#notification > * > .blacklist-title {
  display: inline-block;
  max-width: 30ex;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.item {
  background: no-repeat 0% 50%;
  padding: 2px;
  padding-left: 18px;
  background-size: 16px 16px;
  background-color: hsla(213, 63%, 93%, 0);
  display: block;
  line-height: 20px;
  box-sizing: border-box;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 100%;
}

.item:visited,
.item:link {
  color: hsl(213, 90%, 24%);
}

html[dir=rtl] .item {
  background-position-x: 100%;
  padding-right: 18px;
  padding-left: 2px;
  text-align: right;
}

.window {
  overflow: visible; /* We use visible so that the menu can be a child and shown
                        on :hover. To get this to work we have to set visibility
                        to visible which unfortunately breaks the ellipsis for t
                        he window items */
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA10lEQVQ4y82OSwsBURiGv78of0Ehk2vGwsKlTLllFlMzyJgmaqKJ0fgBVrZWFjb2io2N3WvOiAhNHRuLp7fO6Xn6CAAZ7gLGcoEhw2Xr+Gt4y/78N9fxMRjLG8ylgWMjrJ24GMxtkDax0F2dsd7sHnRmW4TUYyDa1AIpY9OX9ofLCywSdIEyMkGy3nuT7zxf9QlZ74OaqvI1EETDc0mS29wBSW6BynWJO1Cp10DFaok7wNw/CBSKBe6A6LmUEzPcgVw+C0qlBe5A0nMpIUS5A8yleCyCX7gCQoVZHBMa2iYAAAAASUVORK5CYII=");
}

.window-menu {
  position: absolute;
  display: none;
  border: 1px solid #999;
  -webkit-box-shadow: 2px 2px 3px hsla(0, 0%, 0%, .3);
  color: black;
  background-color: white;
  left: 0;
  white-space: nowrap;
  z-index: 2;
  padding: 2px;
  cursor: default;
  border-radius: 4px;
}

/* Made to look like a tooltip using vista/win7 look and feel.
   TODO(arv): Replace with -webkit-appearance once issue 17371 is fixed
 */
#window-tooltip {
  color: #555;
  pointer-events: none;
  border: 1px solid rgb(118, 118, 118);
  border-radius: 3px;
  padding: 0 3px;
  background: -webkit-linear-gradient(white, rgb(228, 229, 240));
  width: auto;
  max-width: 300px;
}

.foreign-session-client {
  float: left;
  max-width: 114px; /* Selected so that we can fit 5 items in EN-US */
  font-weight: normal;
  margin: 0;
  position: relative;
}

html[dir=rtl] .foreign-session-client {
  float: right;
}

.foreign-session-client > p  {
  display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 100%;
  margin: 0 10px;
}

#foreign-sessions .nav {
  max-width: none !important;
}

.nav > a {
  /* no icon */
  padding: 0;
}

.nav > a:after {
  content: '\u00bb'; /* raque gets flipped automatically in rtl */
  font-size: 115%;
  -webkit-padding-start: 2px;
}

#sync-status > div {
  border-radius: 6px;
  padding: 5px 0;
  margin: 10px 0 20px;
  white-space: nowrap;
  overflow-x: hidden;
}

#sync-status > div > * {
  display: inline-block;
  max-width: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 106%;
  margin: 0;
}

.notification.hidden {
  opacity: 0;
  pointer-events: none;
}

/**
 * Unfortunately, there seems to be a bug in WebKit where this div doesn't
 * immediately get layout. It still doesn't have it in 'load', but gains it
 * sometime after.
 *
 * We detect this in the JS by looking for offsetWidth > 0, and when it occurs,
 * remove the 'nolayout' class.
 */
#attribution.nolayout {
  position: static;
  visibility: hidden;
}

#attribution {
  bottom: 5px;
  left: 8px;
  position: fixed;
  text-align: end;
}

html[dir=rtl] #attribution {
  left: auto;
  right: 8px;
}

#attribution.obscured {
  visibility: hidden;
}

html[hasattribution=false] #attribution > div {
  display: none;
}

.sync-button {
  font-size: inherit;
  padding: 0;
  margin: 0;
  -webkit-appearance: none;
  border: 0;
  background: none;
  cursor: pointer;
  text-decoration: underline;
  font-family: inherit;
}

.section {
  position: fixed;
  font-size: 92%;
}

body.noscroll {
  overflow: hidden;
}

html[anim=true][enable-section-animations=true] .section {
  -webkit-transition: top .15s;
}

#login-container {
  display: none;
  margin-top: 5px;
  position: fixed;
  text-align: end;
}

/* A section in menu mode doesn't display its contents at all. Instead it is
rendered as a menu along the bottom of the screen. We have a separate class for
this so that when a hidden section is unhidden it can go back to its previous
collapsed state. */
.section.menu {
  display: none !important;
}

/* A disabled section is not rendered in the UI in any way. Examples of this
state include the 'recently closed' section when we have no data for it, or this
'sync status' section, when there is no status to display. We have a separate
class for this so that when a section is enabled, it can go back to its previous
menu and collapsed state. */
.section.disabled {
  display: none !important;
}

.section > h2 {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 133%;
  font-weight: normal;
  margin: 0;
  position: relative;
}

.section:not([noexpand]) > h2 {
  cursor: pointer;
}

.section > h2 > .disclosure {
  position: absolute;
  left: -15px;
  margin-top: 50%;
  top: -5px;
}

html[dir=rtl] .section > h2 > .disclosure {
  left: auto;
  right: -15px;
  -webkit-transform: rotate(180deg);
}

html[anim=true] .section > h2 > .disclosure {
  -webkit-transition: -webkit-transform .15s;
}

.section:not(.collapsed) > h2 > .disclosure {
  -webkit-transform: rotate(90deg);
}

.section > h2 .back {
  position: absolute;
  left: 0;
  top: 0.56em;
  width: 100%;
  height: 1.5em;
  z-index: 1;
}

.section > h2 span {
  -webkit-padding-end: 0.30em;
  position: relative;
  z-index: 2;
}

.section-close-button {
  -webkit-appearance: none;
  -webkit-transition: opacity .15s;
  background-color: transparent;
  background-image: url(chrome://theme/IDR_CLOSE_BAR);
  background-position: center center;
  background-repeat no-repeat;
  border: 0;
  height: 21px;
  margin-top: -10px;
  position: absolute;
  right: -21px;
  top: 50%;
  width: 21px;
  opacity: 0;
  z-index: 3;
}

html[dir=rtl] .section-close-button {
  left: -21px;
  right: auto;
}

.section > h2:hover .section-close-button,
.section-close-button:hover {
 opacity: 1;
}

.section-close-button:hover {
  background-image: url(chrome://theme/IDR_CLOSE_BAR_H);
}

#closed-sections-bar {
  position: fixed;
  text-align: end;
}

/* closed-sections-bar is bottom aligned for non-ChromeOS build. On ChromeOS,
it goes right under the sections. */
#closed-sections-bar:not([chromeos]) {
  bottom: 14px;
}

#closed-sections-bar > button {
  /* We hide all these buttons by default and turn them on when needed. */
  display: none;

  -webkit-appearance: none;
  background: none;
  border: 0;
  cursor: pointer;
  font: inherit;
  margin: 0;
  -webkit-margin-start: 1.5em;
  padding: 2px 0 0 0;

  /* Note: The font here should end up the same as .section > h2. A different
  percentage is needed because the parent element here has a different size. */
  font-family: Helvetica, Arial, sans-serif;
  font-size: 122%;
  font-weight: normal;
}

#closed-sections-bar > button > img {
  -webkit-transform: rotate(90deg);
  position: relative;
  top: -2px;
  margin-left: 1px;
}

.maxiview {
  padding: 5px 0 30px;
  position: absolute;
  -webkit-mask-attachment: fixed;
  opacity: 0;
}

.maxiview.opaque {
  opacity: 1;
}

.maxiview.collapsing {
  opacity: 0;
}

.maxiview.collapsed {
  display: none;
  opacity: 0;
}

html[anim=true][enable-section-animations=true] .maxiview {
  -webkit-transition: opacity .10s, top .15s;
}

html[anim=true][enable-section-animations=true] .miniview {
  -webkit-transition: opacity .15s;
}

.section > .miniview {
  display: none;
  margin: 10px 0 30px;
  white-space: nowrap;
  overflow-x: hidden;
}

.section.collapsed > * {
  display: none;
}

.section.collapsed > h2 {
  display: block;
}

.section.collapsed > .miniview {
  display: block;
  opacity: 0;
}

.section.collapsed > .miniview.opaque {
  opacity: 1;
}

.section.collapsed > h2 {
  margin-right: 0;
}

.miniview > span  {
  display: inline-block;
  max-width: 114px; /* Selected so that we can fit 5 items in EN-US */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 100%;
  margin: 0 10px;
}

.miniview > span:first-child {
  margin-left: 0;
}

.miniview > span:last-child {
  margin-right: 0;
}

/* small */

.small-layout #main,
.small-layout .section,
.small-layout .maxiview,
.small-layout #login-container,
.small-layout #notification-container,
.small-layout #closed-sections-bar {
  width: 692px;
}

.small-layout  #notification > * {
  max-width: 300px;
}

.small-layout  #notification > span > .blacklist-title {
  max-width: 15ex;
}

/* Ensure we have at least 10px horizontal marging. */
@media (max-width: 712px) {
  #main {
    margin-left: 10px;
    margin-right: 10px;
  }
}
</style>
<style>/* Most Visited */

#most-visited-maxiview {
  position: relative;
  height: 366px;
  -webkit-user-select: none;
}

.thumbnail-container {
  position: absolute;
  color: hsl(213, 90%, 24%);
  text-decoration: none;
  -webkit-transition: left .15s, right .15s, top .15s;
  text-decoration: none;
}

.thumbnail-container:focus {
  outline: none;
}

.thumbnail,
.thumbnail-container > .title {
  width: 207px; /* natural size is 196 */
  height: 129px; /* 136 */
  -webkit-transition: width .15s, height .15s;
}

.thumbnail-container > .title {
  line-height: 16px;
  height: 16px;
  margin: 0;
  margin-top: 4px;
  font-size: 100%;
  font-weight: normal;
  padding: 0 3px;
  opacity: 1;
  -webkit-transition: opacity .15s, width .15s;
  color: black;
}

.thumbnail-wrapper {
  display: block;
  background-size: 212px 132px;
  background: no-repeat 4px 4px;
  background-color: white;
  border-radius: 5px;
  -webkit-transition: background-size .15s;
  position: relative;
}

.filler * {
  visibility: hidden;
}

.filler {
  pointer-events: none;
}

.filler .thumbnail-wrapper {
  visibility: visible;
  border: 3px solid hsl(213, 60%, 92%);
}

.filler .thumbnail {
  visibility: inherit;
  border: 1px solid white;
  padding: 0;
  background-color: hsl(213, 60%, 92%);
}

.edit-bar {
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  padding: 3px;
  padding-bottom: 0;
  height: 17px; /* 23 - 2 * 3 */
  cursor: move;
  font-size: 100%;
  line-height: 17px;
  background: hsl(213, 54%, 95%);
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  position: relative;
  margin-top: 21px;
  margin-bottom: -21px;
  -webkit-transition: margin .15s, background .15s;
}

.edit-bar > * {
  display: block;
  position: relative;
}

.thumbnail-container:focus .edit-bar,
.thumbnail-container:hover .edit-bar {
  margin-top: 0;
  margin-bottom: 0;
  -webkit-transition-delay: .5s, 0s;

  /* We need background-color as well to get the fade out animation correct */
  background-color: hsl(213, 66%, 57%);
  background-image: -webkit-linear-gradient(hsl(213, 87%, 67%),
                                            hsl(213, 66%, 57%));
}

.edit-bar > .spacer {
  -webkit-box-flex: 1;
}

.edit-bar > .pin,
.edit-bar > .remove {
  width: 16px;
  height: 16px;
  cursor: pointer;
  background-image: no-repeat 50% 50%;
}

.edit-bar > .pin {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVQ4y6WTbQqAIAyGR4eRPs5h/to1umYX2J1swhuYlG0lPCLi+zDFERENyqhEhY1EZEqWJmx6ByNLqUw5ZxcY6TS1B4IiBgHfCUp4hyB4BXVYepIngTwQvFeQDq+CniRYBXeSzXqFGsGjbljzF8FZNtcSq6CFUdFF8Psr/2mmmdCSi7I62nlFhg6BYt2lXCEqGgAAAABJRU5ErkJggg==");
}

.edit-bar > .pin:hover {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAkUlEQVQ4y52TwQnAIAxF/6EDuUkppXdH8Sq6gFN2hNTQVGxRqwa+iPAeiRAAWGLWGBsTOmOFYRYbPxIRRiIiZuH5mBAkNhQEiu76E4SSgOFTBGpUkMPUktQEtVKjI7TqV9CSqF5BSWJ6R8hD8qlG7npG8LStc0mv4BstHb0EHvPl0zJNwMzskJU8YtzAOjthcAHXovXMr/dmSgAAAABJRU5ErkJggg==");
}

.edit-bar > .pin:active {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAtElEQVQ4y6WTQQrCMBBFZ+GhcgsRcZltj+AFXEl7gdl5gdKFELyYi6zifJlCWtM40YFHQ8p/mYSEiGgn7IVReBi5agZZOggsdI2wZmn6Idw5587yHUhbWvz03l+SlEHAHwKEY4xPCDBuEuThubYkRUHaqJKkuoVUqa+CmiTvpCooSUIId9MWchDEoSKMMTPfmgVz2wjnEpNgDcLoaC0Y/r3K78eEiRZ09SPpkzwJvU5a6DVDL0iIFWtK1DHEAAAAAElFTkSuQmCC");
}

.pinned .edit-bar > .pin {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAoUlEQVQ4y6WTQQrEIAxFs5j7lTLM0u1cZFbiXCC7uUPBm3XhyuZDhLaTWm0DH0R4zyiGiOghGSRewo3xyoClUTffnWFl6XsBLgH7f7pz7pOlGrvYCgCnlGYIsO4SrOFSJ5KtIB9URWJfIVfqVFCTGJ3YAksSY5yarrAOQDwqYKyZ+dctKG0DNiR1wT6A0dFecPsr3xmmJ+lIviShY5yDMrQA7LABeK+JNKgAAAAASUVORK5CYII=");
}

.pinned .edit-bar > .pin:hover {
  background-image: url(ntp_pin_on_h.png');
}

.pinned .edit-bar > .pin:active {
  background-image: url(ntp_pin_on_p.png');
}

.edit-bar > .remove {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeUlEQVQ4y7WTywmAQAxEH1bjpw53QdiGtkZ7Gi8RRBc1BgO5JMyDfAagA3pgBsrLnE3TAQxW9EYxLRlAkist8k76CigtwCKpNkTVeo+AKmk9QS61O8BZ0AI+Ao6QtTXS74DQCOElhs/ofqTwK0fMNGKWnIDksHMyDRvjd9VHQSi/pgAAAABJRU5ErkJggg==");
}

.edit-bar > .remove:hover {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdklEQVQ4y72TUQrAIAiG/4fdb4yxty4UdYFO6xRklE+msOB7kfyyUgA4mJOpzHBSNUdycWlwdw3NRUd8dQRPn6tYBURUmMHAILHiEchGMpIv5hFYySL0CmbJUs1vgtQV0o+Y+8ZII6VbOTNMN3QkH6ZtjHPTHLxiHvw7LRQlVgAAAABJRU5ErkJggg==");
}

.edit-bar > .remove:active {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVQ4y2NgYGBgAWJ/IF4LxDuIxJ1QPSC9DIFAPBOI00jEM6F6GdaToTnNwsKiDEj3MECdRK4BMzEM+P//fwwQY3gJJAaSI8YAkML/yIZgE8NpALoGbJoJGoBmyH9sXqKtARR5geJApDgayUlIPZQmZXBmAgmQgqG2BzNAs2QoEHdDBYnB3VA9DACUmgUVtMbe9gAAAABJRU5ErkJggg==");
}

.thumbnail-container > .title > div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  background: no-repeat 0 50%;
  background-size: 16px;
  padding-left: 20px; /* we cannot use padding start here because even if we set
                         the direction we always want the icon on the same side
                      */
  padding-right: 0;
}

html[dir=rtl] .thumbnail-container > .title > div {
  background-position-x: 100%;
  padding-left: 0;
  padding-right: 20px;
  text-align: right;
}

.thumbnail {
  border: 3px solid hsl(213, 63%, 93%);
  padding: 1px;
  border-radius: 5px;
  display: block;
  -webkit-box-shadow: 0px 2px 2px hsla(0, 0%, 0%, 0);
  -webkit-transition: width .15s, height .15s, border-color .15s,
      border-top-left-radius .15s, border-top-right-radius .15s,
      -webkit-box-shadow .15s;
}

.edit-mode-border {
  border-radius: 4px;

  /* when dragged over we move this */
  position: relative;
  -webkit-transition: top .15s, left .15s;
}

.thumbnail-container:focus .thumbnail,
.thumbnail-container:hover .thumbnail {
  border-color: hsl(213, 66%, 57%);
  -webkit-box-shadow: 0px 2px 2px hsla(0, 0%, 0%, 0);
  border-top-left-radius: 0;
  border-top-right-radius: 0;

  background-image: -webkit-linear-gradient(hsla(0, 0%, 0%, 0),
                                            hsla(0, 0%, 47%, 0) 85%,
                                            hsla(0, 0%, 47%, 0.2));

  /* delay border radius transition as much as the edit bar slide delay */
  -webkit-transition-delay: 0, 0, 0, .5s, .5s, 0;
}

.thumbnail-container:focus > .edit-mode-border,
.thumbnail-container:hover > .edit-mode-border {
  background-color: hsl(213, 66%, 57%);
  -webkit-box-shadow: 0px 2px 2px hsla(0, 0%, 0%, .5);
}

.dragging,
.dragging * {
  -webkit-transition: none !important;
}

.dragging > .title {
  opacity: 0;
}

@-webkit-keyframes 'fade-in' {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

.fade-in {
  -webkit-animation: 'fade-in' .15s;
}

@media (max-width: 940px) {
  #most-visited-maxiview {
    height: 294px;
  }

  .thumbnail,
  .thumbnail-container > .title {
    width: 150px;
    height: 93px;
  }

  .thumbnail-container > .title {
    height: auto;
  }

  .thumbnail-wrapper {
    background-size: 150px 93px;
  }
}

#most-visited-settings {
  position: absolute;
  top: 1px;
  right: 0;
  border: 0;
  cursor: pointer;
  font-size: 70%;
  margin: 0;
  padding: 0;
  text-decoration: underline;
  visibility: hidden;
  -webkit-padding-start: 3px;
  z-index: 3;
}

html[dir=rtl] #most-visited-settings {
  left: 0;
  right: auto;
}

#most-visited:not(.collapsed) #most-visited-settings.has-blacklist {
  visibility: visible;
}
</style>
<style>/* Apps */

#apps-content {
  position: relative;
  max-width: 780px;  /* (124 + margin * 2) * 6 */
}

html.apps-promo-visible #apps-content {
  max-width: 650px; /* (124 + margin * 2) * 5 */
}

#apps-maxiview {
  overflow: hidden;
}

/*
We don't need to do anything for html.apps-promo-visible because there is
enough extra space in the small grid layout.
*/
.small-layout #apps-content,
.small-layout html.apps-promo-visible #apps-content {
  max-width: 520px;  /* (124 + margin * 2) * 4 */
}

.app,
.app[new=installed] {
  box-sizing: border-box;
  -webkit-perspective: 400;
  border-radius: 10px;
  color: black;
  margin: 5px 3px;
  position: absolute;
  height: 136px;
  width: 124px; /* 920 / 7 - margin * 2 */
  visibility: hidden;
}

.app a {
  border-radius: 10px;
  bottom: 0;
  left: 0;
  position: absolute;
  right: 0;
  top: 0;
}

.app a {
  -webkit-transition: background-color .5s;
  background: rgba(255, 255, 255, 0) /* transparent white */
              no-repeat center 10px;
  background-size: 96px 96px;
  font-family: Helvetica, Arial, sans-serif;
  font-size: 107%;
  overflow: hidden;
  padding: 111px 10px 10px;  /* 10 + 96 + 5 */
  text-align: center;
  text-decoration: none;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.app .app-settings {
  background-color: transparent;
  background-position: center center;
  background-repeat: no-repeat;
  border: 0;
  height: 14px;
  padding: 0;
  position: absolute;
  right: 5px;
  top: 5px;
  width: 14px;
}

.app > .app-settings {
  -webkit-transition: opacity .3s;
  -webkit-transition-delay: 0;
  background-image: url(chrome://theme/IDR_BALLOON_WRENCH);
  opacity: 0;
}

.app > .app-settings:hover {
  -webkit-transition: none;
  background-image: url(chrome://theme/IDR_BALLOON_WRENCH_H);
}

.app:hover > .app-settings,
.app > .app-settings:focus {
  -webkit-transition-delay: .5s;
  opacity: .9;
}

.app.dragging > .app-settings {
  background-image: none;
}

.app.dragging {
  opacity: .7;
}

#apps-content[launcher-animations=true] .app {
  -webkit-transition: top .2s, left .2s, right .2s, opacity .2s;
}

#apps-content.visible .app {
  visibility: visible;
}

@-webkit-keyframes bounce {
  0% {
    -webkit-transform: scale(0, 0);
  }

  60% {
    -webkit-transform: scale(1.2, 1.2);
  }

  100% {
    -webkit-transform: scale(1, 1);
  }
}

html[install-animation-enabled=true] .app[new=new] {
  opacity: 0;
}

html[install-animation-enabled=true] .app[new=installed] {
  -webkit-animation: bounce .5s ease-in-out;
  -webkit-transition: opacity .5s;
}

.app.web-store-entry > a {
  background-image: url("chrome://theme/IDR_WEBSTORE_ICON");
}

menu > button.default {
  font-weight: bold;
}

#apps-promo {
  display: none;
}

html.apps-promo-visible #apps-promo {
  height: 125px;
  -webkit-padding-start: 125px;
  display: table-cell;
  vertical-align: text-bottom;
}

#apps-promo-heading {
  font-size: 115%;
  font-weight: bold;
  margin-bottom: 5px;
  -webkit-margin-start: 3px;
}

#apps-promo-hide {
  -webkit-appearance: none;
  -webkit-transition: opacity .15s;
  background-color: transparent;
  border: 0;
  cursor: pointer;
  font-family: inherit;
  font-size: 90%;
  text-decoration: underline;
  margin-top: 2px;
}

html[dir=rtl] #apps-promo-hide {
  float: left;
}

/*
We position the web store entry all by its lonesome in the top of the rightmost
column when there is at least one full row of apps. Note that this is similar,
but different than its position during promo (html.apps-promo-visible), so we
never set .loner while the promo is running.
*/
.app.web-store-entry.loner {
  position: absolute;
  left: 100%;
  top: 0;
}

html[dir=rtl] .app.web-store-entry.loner {
  right: 100%;
}

.g-button-basic {
  display: inline-block;
  border-width: 6px 10px 12px 6px;
  -webkit-border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAABHCAYAAABf7PRNAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABXNJREFUeNrsmz2IJEUUgF9Vd8/OzultcAgnGCi4B16oiYiJmhibG5kLhubmwmWiwRkaCAbCXWKgIJiJGKweihys58ndOc5f/1XXK9+rru7puV23e7N7s1PwmKnpGuiv3qtXr15VKecccLnx1S/us1tH8NfDFVisfxNe/gTnPsdi9sns9vvHVG+g/Kdi8OvvfeleuXYdXn35Wbg0HoOxCiqCdwL5cwOwyB0cP1jBz3f+gN9+/xXM/Phw/s2Hd+kxBnCM1IvvuPHoKrz12gswGSWglQKlHCCBK/8dRElpHCwyhGkawVhXgCaDWWYwv/P1t90O0jdvH8Hh4XOwytFruX2gNSjqHGliEWFO4On8AWSz+3CQVKCi8buEtE8yIonY0uPZqoS0JOCFhdLS00RBRr2WFShyYM9ShIfTFNLpPciXjwCqgk3hCj26FJowGMb8bZlZEvAdMBkp/8m/GSsPfEGWm5Kmi9U/YMuMbKC14qdImKhi8eBpXkGSxOsOoHpaynTlVZlClS/BViU55w3NsakTHTCzrsEJcuI7wld9HVGmqaO1/t0dWu+gO2VMkoQxXoPHjsYB7PmnxlS+XmAkEtx5aBKei9v5WEHQqof2vrv9g2+InXl+64oO0vYCIEHbqgKnELTDpuuE8tXKY0W6luGk9ca1tqEdF6ruEHBOpuZr4GDmZzDEnX/UVs5Rm1PiwdsO6AX3Md9jvSZZ4z2+Km613VCLB+9Ybx/4Ccie8fHEkw819XWjxrGh3FmtNfMhzo1AEWk1pnSoOrnccA7nhjSNAUFb2/m70CzMRtTWD05rWY0E7rpdJ1XltZXD2W5q7dxI0OLaPwhdpLQa9++PA+ZxP5XXzg1pzEsd5e0YH6Lxk71m5Xv1niDGgyvv1cksVB3MK9EBDAYZErLy+GZwp9tec8IDmEHzOAatexNvXIJo8P739+A8iyXsFMJEbh1ckNUZN1Bqo9cuxHpc8fjWnRWqT0pIjdxcx7n1zeN++uLkQ3Buvi51jONw58ZOzbcPmVVf76zPxZn6gJxCsG8MHdQkXamOMsHrd+8PtwO42sjAgN9+E71GCb5tSM7tFJORauptBqZP4xy1IZk2L04UNKlm6V4dhyQi6oMAvnGob9U8rgaYukX5pt6M782tsx7w1iGKX6RA/zzOWtZs7q7j1SVrHAaGrBWBR36cb4dXb0PWvtSTQj4UoEnzcT0cuC51t7QbsvZlYCI+DaGi9gSBQyM6r15vEw8IYJQLObYmEVFx7C40Vufxiq7XYlvnpioHWpkavH+z8YmOWdfTeO/eGYml9VhcrWcEqXn1ELX17ZiuNxSUOmWsbHvqqbMq2wgERAcwQ4+CbEk5X159u8g3tf4/RcMFLTvwHfgOfAe+A9+B78B34OJKvR6nBbmm9YmNwqkni2KXpecCLwoDRQmQF9onHKuqaI+FSCu2XEFlcn9a86zdoDrLWiyoYQWFb2xI46XYZak1mRdnqzNzCgxeFul05EjLaFlMfV/rlOSEiMLK6+TbHB9MdjY/CY72+5XJ34jLGWm7OvP4hMRikn3AfHYEnR1k79XRLD+dJ5fB8MK9OQKyJWJ1Asv9q2Du/3gL6quVtoFnW54cvH3jg2jv8keRzSCy5VZo2kYjkn0o//7p5vKHj7+gn6Ykj0hmJCsG56uH+/GVa8/sPf/m62p88BK5xj0y+yQcihGZYLfz43vl3e+OMJ8y6DIA/0uyIMkYiu9U8/3KCcnTUN+6ncD6LqYSCN+MZd4oYMeWBuBl+F6wV8dOAxXGQQHrS+ZaKDgGljKwZeGTWW38WAMXnEAepjrdCWuVIGgIXBh4TOAzjYNTHVPWQcNdUcJN3QXQrvjLp/8JMACZP99HrN477QAAAABJRU5ErkJggg==") 6 10 12 6;
  font-size: 1.3em;
  color: #fff !important;
  text-decoration: none;
  font-weight: bold;
  text-align: center;
  padding: 2px 10px;
  white-space: nowrap;
}
</style>
<style>menu {
  display: none;
  position: fixed;
  border: 1px solid rgba(0, 0, 0, .50);
  -webkit-box-shadow: 0px 2px 4px rgba(0, 0, 0, .50);
  color: black;
  background: -webkit-linear-gradient(#fff, #eee);
  left: 0;
  white-space: nowrap;
  padding: 8px 0;
  margin: 0;
  cursor: default;
  border-radius: 3px;
  z-index: 3;
}

menu > * {
  box-sizing: border-box;
  display: block;
  margin: 0;
  width: 100%;
  text-align: start;
}

menu > :not(hr) {
  -webkit-appearance: none;
  background: transparent;
  font: inherit;
  border: 0;
  line-height: 18px;
  padding: 0 19px;
  overflow: hidden;
  text-overflow: ellipsis;
}

menu > hr {
  background: -webkit-linear-gradient(left,
                                      rgba(0, 0, 0, .10),
                                      rgba(0, 0, 0, .02) 96%);
  border: 0;
  height: 1px;
  margin: 8px 0;
}

menu > [disabled] {
  color: rgba(0, 0, 0, .3);
}

menu > [hidden] {
  display: none;
}

menu > :not(hr)[selected] {
  background-color: #dce5fa;
}

menu > :not(hr)[selected]:active {
  background-color: #426dc9;
  color: #fff;
}

menu > [checked]:before {
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAACxMAAAsTAQCanBgAAABGSURBVBjTY2DAD4yBWJCQgndArMQAVWmMQ8F/mCIlqIAxFgXvYNYpIQmUoymA2yCIJPEfmwIGHFYY4/PNXawK/v//TxADABR+MoriwNe9AAAAAElFTkSuQmCC");
  width: 9px;
  height: 9px;
  display: inline-block;
  vertical-align: 50%;
  margin: 0 5px;
}

menu > [checked] {
  -webkit-padding-start: 0;
}

menu > [selected][checked]:active:before {
  content: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAACxMAAAsTAQCanBgAAABOSURBVBjTY/j//z8DHmwMxIKEFLwDYiUQRxAqgE3Bf5giJaiAMRYF72DWKSEJlKMpAGuEWQeT+I+uAKYImxUobkR37F0snmBgIBBOYAwABR4Jwdv/yUkAAAAASUVORK5CYII=");
}
</style>
<script>

/**
 * Bitmask for the different UI sections.
 * This matches the Section enum in ../webui/shown_sections_handler.h
 * @enum {number}
 */
var Section = {
  THUMB: 1 << 0,
  APPS: 1 << 6
};

// These are used to put sections into menu mode and are part of the
// |shownSections| bitmask, but are not sections themselves.
var MENU_THUMB = 1 << (0 + 16);
var MENU_RECENT = 1 << (2 + 16);
var MENU_APPS = 1 << (6 + 16);

// TODO(aa): This state is duplicated. We keep this variable up to date, but we
// also have the same information in the DOM. We can probably just have the DOM
// be the truth and translate to and from the bitmask when needed.
var shownSections = templateData['shown_sections'];

// Until themes can clear the cache, force-reload the theme stylesheet.
document.write('<link id="themecss" rel="stylesheet" ' +
               'href="chrome://theme/css/newtab.css?' +
               Date.now() + '">');

function useSmallGrid() {
  return window.innerWidth <= 940;
}

function isRtl() {
  return templateData['textdirection'] == 'rtl';
}

// Parse any name value pairs passed through the URL hash.
var hashParams = (function() {
  var result = {};
  if (location.hash.length) {
    location.hash.substr(1).split('&').forEach(function(pair) {
      pair = pair.split('=');
      if (pair.length != 2) {
        throw new Error('Unexpected hash value: ' + location.hash);
      }

      result[pair[0]] = pair[1];
    });
  }
  return result;
})();

// Reflect the mode param as an attribute so we can use CSS attribute selectors
// on it.
if ('mode' in hashParams) {
  document.documentElement.setAttribute('mode', hashParams['mode']);
}

</script>
</head>
<body class="loading"
      i18n-values=".style.fontFamily:fontfamily;.style.fontSize:fontsize">

<div id="attribution" class="attribution nolayout">
  <div i18n-content="attributionintro"></div>
  <img id="attribution-img">
</div>

<div id="main">

  <div id="notification-container">
    <div id="notification">
      <div>&nbsp;</div>
      <div class="link"><div class="link-color" id="action-link"></div></div>
      <button id="notification-close"></button>
    </div>
  </div>

  <div id="login-container">
    <span id="login-username"></span>
  </div>

  <div class="maxiview" id="apps-maxiview">
    <div id="apps-promo">
      <p id="apps-promo-heading"></p>
      <a class="g-button-basic" id="apps-promo-link" href=""></a><br>
      <button id="apps-promo-hide"></button>
    </div>
    <div id="apps-content"></div>
  </div>
  <div class="maxiview" id="most-visited-maxiview"></div>

  <div class="sections">
    <!-- Start disabled. We only enable once we have installed default apps. -->
    <div id="apps" class="section disabled" section="APPS">
      <h2>
        <img class="disclosure" img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9oIGRQbOY8MjgMAAAA8SURBVBjTY2BAAzdv3vwPBAzImAGbInSFWBU9f/4cRSFWRb9+/UJRiFMRTOGNGzf+k28SUW4iynfo4QQAj22WmutXxVsAAAAASUVORK5CYII=">
        <div class="back"></div>
        <span i18n-content="apps"></span>
        <button class="section-close-button"></button>
      </h2>
      <div class="miniview"></div>
    </div>

    <div id="most-visited" class="section" section="THUMB">
      <h2>
        <img class="disclosure" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9oIGRQbOY8MjgMAAAA8SURBVBjTY2BAAzdv3vwPBAzImAGbInSFWBU9f/4cRSFWRb9+/UJRiFMRTOGNGzf+k28SUW4iynfo4QQAj22WmutXxVsAAAAASUVORK5CYII=">
        <div class="back"></div>
        <span i18n-content="mostvisited"></span>
        <button id="most-visited-settings" i18n-content="restorethumbnails">
        </button>
        <button class="section-close-button"></button>
      </h2>
      <div class="miniview"></div>
    </div>

    <!-- Start this section disabled because it might not have data, and looks
         silly without any. -->
    <div id="recently-closed" class="section collapsed disabled"
        section="RECENT" noexpand="true">
      <h2>
        <div class="back"></div>
        <span i18n-content="recentlyclosed"></span>
        <button class="section-close-button"></button>
      </h2>
      <div class="miniview"></div>
    </div>

    <!-- Start disabled until sync is enabled and foreign sessions are
         available. -->
    <div id="foreign-sessions" class="section collapsed disabled"
        section="SYNC">
      <h2>
        <div class="back"></div>
        <span i18n-content="foreignsessions"></span>
      </h2>
      <div class="miniview"></div>
    </div>

    <div id="sync-status" class="section disabled">
      <div>
        <h3></h3>
        <span></span>
      </div>
    </div>
  </div>

  <div id="closed-sections-bar">
    <!-- The default visibility of these buttons needs to be the opposite of the
         default visibility of the corresponding sections. -->
    <button id="apps-button"
            menu="#apps-menu">
      <span i18n-content="apps"></span>
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9oIGRQbOY8MjgMAAAA8SURBVBjTY2BAAzdv3vwPBAzImAGbInSFWBU9f/4cRSFWRb9+/UJRiFMRTOGNGzf+k28SUW4iynfo4QQAj22WmutXxVsAAAAASUVORK5CYII=">
    </button>
    <button id="most-visited-button"
            menu="#most-visited-menu">
      <span i18n-content="mostvisited"></span>
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9oIGRQbOY8MjgMAAAA8SURBVBjTY2BAAzdv3vwPBAzImAGbInSFWBU9f/4cRSFWRb9+/UJRiFMRTOGNGzf+k28SUW4iynfo4QQAj22WmutXxVsAAAAASUVORK5CYII=">
    </button>
    <button id="recently-closed-button"
            menu="#recently-closed-menu">
      <span i18n-content="recentlyclosed"></span>
      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9oIGRQbOY8MjgMAAAA8SURBVBjTY2BAAzdv3vwPBAzImAGbInSFWBU9f/4cRSFWRb9+/UJRiFMRTOGNGzf+k28SUW4iynfo4QQAj22WmutXxVsAAAAASUVORK5CYII=">
    </button>
  </div>
</div>  <!-- main -->

<div class="window-menu" id="window-tooltip"></div>

<command id="clear-all-blacklisted" i18n-values=".label:restorethumbnails">
<command id="apps-launch-command">
<command id="apps-options-command" i18n-values=".label:appoptions">
<command id="apps-uninstall-command" i18n-values=".label:appuninstall">
<command id="apps-create-shortcut-command"
    i18n-values=".label:appcreateshortcut">
<command id="apps-launch-type-pinned" i18n-values=".label:applaunchtypepinned"
    launch-type="0">
<command id="apps-launch-type-regular" i18n-values=".label:applaunchtyperegular"
    launch-type="1">
<command id="apps-launch-type-window"
    i18n-values=".label:applaunchtypewindow" launch-type="3">
<command id="apps-launch-type-fullscreen"
    i18n-values=".label:applaunchtypefullscreen" launch-type="2">

<!-- These are populated dynamically -->
<menu id="apps-menu"></menu>
<menu id="most-visited-menu"></menu>
<menu id="recently-closed-menu"></menu>

<menu id="app-context-menu">
  <button class="default" command="#apps-launch-command"></button>
  <hr>
  <button command="#apps-launch-type-regular" launch-type="1"></button>
  <button command="#apps-launch-type-pinned" launch-type="0"></button>
  <button id="apps-launch-type-window-menu-item"
      command="#apps-launch-type-window" launch-type="3"></button>
  <button command="#apps-launch-type-fullscreen" launch-type="2"></button>
  <hr>
  <button command="#apps-options-command"></button>
  <button command="#apps-uninstall-command"></button>
  <hr id="apps-create-shortcut-command-separator">
  <button id="apps-create-shortcut-command-menu-item"
      command="#apps-create-shortcut-command"></button>
</menu>

</body>

<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This is a simple template engine inspired by JsTemplates
 * optimized for i18n.
 *
 * It currently supports two handlers:
 *
 *   * i18n-content which sets the textContent of the element
 *
 *     <span i18n-content="myContent"></span>
 *     i18nTemplate.process(element, {'myContent': 'Content'});
 *
 *   * i18n-values is a list of attribute-value or property-value pairs.
 *     Properties are prefixed with a '.' and can contain nested properties.
 *
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>
 *     i18nTemplate.process(element, {
 *       'myTitle': 'Title',
 *       'fontSize': '13px'
 *     });
 */

var i18nTemplate = (function() {
  /**
   * This provides the handlers for the templating engine. The key is used as
   * the attribute name and the value is the function that gets called for every
   * single node that has this attribute.
   * @type {Object}
   */
  var handlers = {
    /**
     * This handler sets the textContent of the element.
     */
    'i18n-content': function(element, attributeValue, obj) {
      element.textContent = obj[attributeValue];
    },

    /**
     * This handler adds options to a select element.
     */
    'i18n-options': function(element, attributeValue, obj) {
      var options = obj[attributeValue];
      options.forEach(function(values) {
        var option = typeof values == 'string' ? new Option(values) :
            new Option(values[1], values[0]);
        element.appendChild(option);
      });
    },

    /**
     * This is used to set HTML attributes and DOM properties,. The syntax is:
     *   attributename:key;
     *   .domProperty:key;
     *   .nested.dom.property:key
     */
    'i18n-values': function(element, attributeValue, obj) {
      var parts = attributeValue.replace(/\s/g, '').split(/;/);
      for (var j = 0; j < parts.length; j++) {
        var a = parts[j].match(/^([^:]+):(.+)$/);
        if (a) {
          var propName = a[1];
          var propExpr = a[2];

          // Ignore missing properties
          if (propExpr in obj) {
            var value = obj[propExpr];
            if (propName.charAt(0) == '.') {
              var path = propName.slice(1).split('.');
              var object = element;
              while (object && path.length > 1) {
                object = object[path.shift()];
              }
              if (object) {
                object[path] = value;
                // In case we set innerHTML (ignoring others) we need to
                // recursively check the content
                if (path == 'innerHTML') {
                  process(element, obj);
                }
              }
            } else {
              element.setAttribute(propName, value);
            }
          } else {
            console.warn('i18n-values: Missing value for "' + propExpr + '"');
          }
        }
      }
    }
  };

  var attributeNames = [];
  for (var key in handlers) {
    attributeNames.push(key);
  }
  var selector = '[' + attributeNames.join('],[') + ']';

  /**
   * Processes a DOM tree with the {@code obj} map.
   */
  function process(node, obj) {
    var elements = node.querySelectorAll(selector);
    for (var element, i = 0; element = elements[i]; i++) {
      for (var j = 0; j < attributeNames.length; j++) {
        var name = attributeNames[j];
        var att = element.getAttribute(name);
        if (att != null) {
          handlers[name](element, att, obj);
        }
      }
    }
  }

  return {
    process: process
  };
})();
</script>
<script>
i18nTemplate.process(document, templateData);
</script>
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// TODO(arv): Namespace

/**
 * The local strings get injected into the page using a variable named
 * {@code templateData}. This class provides a simpler interface to access those
 * strings.
 *
 * @param {Object} opt_templateData Optional object containing translated
 *     strings.  If this is not supplied during construction, it can be
 *     assigned to the templateData property after construction.  If all else
 *     fails, the value of window.templateDate will be used.
 * @constructor
 */
function LocalStrings(opt_templateData) {
  this.templateData = opt_templateData;
}

// Start of anonymous namespace.
(function() {

/**
 * Returns a formatted string where $1 to $9 are replaced by the second to the
 * tenth argument.
 * @param {string} s The format string.
 * @param {...string} The extra values to include in the formatted output.
 * @return {string} The string after format substitution.
 */
function replaceArgs(s, args) {
  return s.replace(/\$[$1-9]/g, function(m) {
    return (m == '$$') ? '$' : args[m[1]];
  });
}

/**
 * Returns a string after removing Windows-style accelerators.
 * @param {string} s The input string that may contain accelerators.
 * @return {string} The resulting string with accelerators removed.
 */
function trimAccelerators(s) {
  return s.replace(/&{1,2}/g, function(m) {
    return (m == '&&') ? '&' : '';
  });
}

LocalStrings.prototype = {
  /**
   * The template data object.
   * @type {Object}
   */
  templateData: null,

  /**
   * Gets a localized string by its id.
   * @param {string} s The ID of the string we want.
   * @return {string} The localized string.
   */
  getString: function(id) {
    // TODO(arv): We should not rely on a global variable here.
    return (this.templateData || window.templateData)[id] || '';
  },

  /**
   * Returns a formatted localized string where $1 to $9 are replaced by the
   * second to the tenth argument.
   * @param {string} id The ID of the string we want.
   * @param {...string} The extra values to include in the formatted output.
   * @return {string} The formatted string.
   */
  getStringF: function(id, var_args) {
    return replaceArgs(this.getString(id), arguments);
  },
};

// End of anonymous namespace.
})();
</script>
<script>/**
 * Whitelist of tag names allowed in parseHtmlSubset.
 * @type {[string]}
 */
var allowedTags = ['A', 'B', 'STRONG'];

/**
 * Parse a very small subset of HTML.
 * @param {string} s The string to parse.
 * @throws {Error} In case of non supported markup.
 * @return {DocumentFragment} A document fragment containing the DOM tree.
 */
var allowedAttributes = {
  'href': function(node, value) {
    // Only allow a[href] starting with http:// and https://
    return node.tagName == 'A' && (value.indexOf('http://') == 0 ||
        value.indexOf('https://') == 0);
  },
  'target': function(node, value) {
    // Allow a[target] but reset the value to "".
    if (node.tagName != 'A')
      return false;
    node.setAttribute('target', '');
    return true;
  }
}

/**
 * Parse a very small subset of HTML.  This ensures that insecure HTML /
 * javascript cannot be injected into the new tab page.
 * @param {string} s The string to parse.
 * @throws {Error} In case of non supported markup.
 * @return {DocumentFragment} A document fragment containing the DOM tree.
 */
function parseHtmlSubset(s) {
  function walk(n, f) {
    f(n);
    for (var i = 0; i < n.childNodes.length; i++) {
      walk(n.childNodes[i], f);
    }
  }

  function assertElement(node) {
    if (allowedTags.indexOf(node.tagName) == -1)
      throw Error(node.tagName + ' is not supported');
  }

  function assertAttribute(attrNode, node) {
    var n = attrNode.nodeName;
    var v = attrNode.nodeValue;
    if (!allowedAttributes.hasOwnProperty(n) || !allowedAttributes[n](node, v))
      throw Error(node.tagName + '[' + n + '="' + v + '"] is not supported');
  }

  var r = document.createRange();
  r.selectNode(document.body);
  // This does not execute any scripts.
  var df = r.createContextualFragment(s);
  walk(df, function(node) {
    switch (node.nodeType) {
      case Node.ELEMENT_NODE:
        assertElement(node);
        var attrs = node.attributes;
        for (var i = 0; i < attrs.length; i++) {
          assertAttribute(attrs[i], node);
        }
        break;

      case Node.COMMENT_NODE:
      case Node.DOCUMENT_FRAGMENT_NODE:
      case Node.TEXT_NODE:
        break;

      default:
        throw Error('Node type ' + node.nodeType + ' is not supported');
    }
  });
  return df;
}
</script>

<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

const cr = (function() {

  /**
   * Whether we are using a Mac or not.
   * @type {boolean}
   */
  const isMac = /Mac/.test(navigator.platform);

  /**
   * Whether this is on the Windows platform or not.
   * @type {boolean}
   */
  const isWindows = /Win/.test(navigator.platform);

  /**
   * Whether this is on chromeOS or not.
   * @type {boolean}
   */
  const isChromeOS = /CrOS/.test(navigator.userAgent);

  /**
   * Whether this is on vanilla Linux (not chromeOS).
   * @type {boolean}
   */
  const isLinux = /Linux/.test(navigator.userAgent);

  /**
   * Whether this uses the views toolkit or not.
   * @type {boolean}
   */
  const isViews = isWindows || isChromeOS;

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * "a.b.c" -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @param {*=} opt_object The object to expose at the end of the path.
   * @param {Object=} opt_objectToExportTo The object to add the path to;
   *     default is {@code window}.
   * @private
   */
  function exportPath(name, opt_object, opt_objectToExportTo) {
    var parts = name.split('.');
    var cur = opt_objectToExportTo || window /* global */;

    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length && opt_object !== undefined) {
        // last part and we have an object; use it
        cur[part] = opt_object;
      } else if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  };

  // cr.Event is called CrEvent in here to prevent naming conflicts. We also
  // store the original Event in case someone does a global alias of cr.Event.
  const DomEvent = Event;

  /**
   * Creates a new event to be used with cr.EventTarget or DOM EventTarget
   * objects.
   * @param {string} type The name of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles. Default is false.
   * @param {boolean=} opt_preventable Whether the default action of the event
   *     can be prevented.
   * @constructor
   * @extends {DomEvent}
   */
  function CrEvent(type, opt_bubbles, opt_preventable) {
    var e = cr.doc.createEvent('Event');
    e.initEvent(type, !!opt_bubbles, !!opt_preventable);
    e.__proto__ = CrEvent.prototype;
    return e;
  }

  CrEvent.prototype = {
    __proto__: DomEvent.prototype
  };

  /**
   * Fires a property change event on the target.
   * @param {EventTarget} target The target to dispatch the event on.
   * @param {string} propertyName The name of the property that changed.
   * @param {*} newValue The new value for the property.
   * @param {*} oldValue The old value for the property.
   */
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) {
    var e = new CrEvent(propertyName + 'Change');
    e.propertyName = propertyName;
    e.newValue = newValue;
    e.oldValue = oldValue;
    target.dispatchEvent(e);
  }

  /**
   * The kind of property to define in {@code defineProperty}.
   * @enum {number}
   */
  const PropertyKind = {
    /**
     * Plain old JS property where the backing data is stored as a "private"
     * field on the object.
     */
    JS: 'js',

    /**
     * The property backing data is stored as an attribute on an element.
     */
    ATTR: 'attr',

    /**
     * The property backing data is stored as an attribute on an element. If the
     * element has the attribute then the value is true.
     */
    BOOL_ATTR: 'boolAttr'
  };

  /**
   * Helper function for defineProperty that returns the getter to use for the
   * property.
   * @param {string} name
   * @param {cr.PropertyKind} kind
   * @return {function():*} The getter for the property.
   */
  function getGetter(name, kind) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function() {
          return this[privateName];
        };
      case PropertyKind.ATTR:
        return function() {
          return this.getAttribute(name);
        };
      case PropertyKind.BOOL_ATTR:
        return function() {
          return this.hasAttribute(name);
        };
    }
  }

  /**
   * Helper function for defineProperty that returns the setter of the right
   * kind.
   * @param {string} name The name of the property we are defining the setter
   *     for.
   * @param {cr.PropertyKind} kind The kind of property we are getting the
   *     setter for.
   * @param {function(*):void} opt_setHook A function to run after the property
   *     is set, but before the propertyChange event is fired.
   * @return {function(*):void} The function to use as a setter.
   */
  function getSetter(name, kind, opt_setHook) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function(value) {
          var oldValue = this[privateName];
          if (value !== oldValue) {
            this[privateName] = value;
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.ATTR:
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            this.setAttribute(name, value);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.BOOL_ATTR:
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            if (value)
              this.setAttribute(name, name);
            else
              this.removeAttribute(name);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };
    }
  }

  /**
   * Defines a property on an object. When the setter changes the value a
   * property change event with the type {@code name + 'Change'} is fired.
   * @param {!Object} obj The object to define the property for.
   * @param {string} name The name of the property.
   * @param {cr.PropertyKind=} opt_kind What kind of underlying storage to use.
   * @param {function(*):void} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   */
  function defineProperty(obj, name, opt_kind, opt_setHook) {
    if (typeof obj == 'function')
      obj = obj.prototype;

    var kind = opt_kind || PropertyKind.JS;

    if (!obj.__lookupGetter__(name)) {
      obj.__defineGetter__(name, getGetter(name, kind));
    }

    if (!obj.__lookupSetter__(name)) {
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));
    }
  }

  /**
   * Counter for use with createUid
   */
  var uidCounter = 1;

  /**
   * @return {number} A new unique ID.
   */
  function createUid() {
    return uidCounter++;
  }

  /**
   * Returns a unique ID for the item. This mutates the item so it needs to be
   * an object
   * @param {!Object} item The item to get the unique ID for.
   * @return {number} The unique ID for the item.
   */
  function getUid(item) {
    if (item.hasOwnProperty('uid'))
      return item.uid;
    return item.uid = createUid();
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented.
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) {
    var e = new cr.Event(type, opt_bubbles, opt_cancelable);
    return target.dispatchEvent(e);
  }

  /**
   * @param {string} name
   * @param {!Function} fun
   */
  function define(name, fun) {
    var obj = exportPath(name);
    var exports = fun();
    for (var propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,
                                                               propertyName);
      if (propertyDescriptor)
        Object.defineProperty(obj, propertyName, propertyDescriptor);
    }
  }

  /**
   * Document used for various document related operations.
   * @type {!Document}
   */
  var doc = document;


  /**
   * Allows you to run func in the context of a different document.
   * @param {!Document} document The document to use.
   * @param {function():*} func The function to call.
   */
  function withDoc(document, func) {
    var oldDoc = doc;
    doc = document;
    try {
      func();
    } finally {
      doc = oldDoc;
    }
  }

  /**
   * Adds a {@code getInstance} static method that always return the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  function addSingletonGetter(ctor) {
    ctor.getInstance = function() {
      return ctor.instance_ || (ctor.instance_ = new ctor());
    };
  }

  return {
    addSingletonGetter: addSingletonGetter,
    isChromeOS: isChromeOS,
    isMac: isMac,
    isWindows: isWindows,
    isLinux: isLinux,
    isViews: isViews,
    define: define,
    defineProperty: defineProperty,
    PropertyKind: PropertyKind,
    createUid: createUid,
    getUid: getUid,
    dispatchSimpleEvent: dispatchSimpleEvent,
    dispatchPropertyChange: dispatchPropertyChange,

    /**
     * The document that we are currently using.
     * @type {!Document}
     */
    get doc() {
      return doc;
    },
    withDoc: withDoc,
    Event: CrEvent
  };
})();
</script>
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/** @fileoverview EventTracker is a simple class that manages the addition and
 *  removal of DOM event listeners. In particular, it keeps track of all
 *  listeners that have been added and makes it easy to remove some or all of
 *  them without requiring all the information again. This is particularly
 *  handy when the listener is a generated function such as a lambda or the
 *  result of calling Function.bind.
 */

// Use an anonymous function to enable strict mode just for this file (which
// will be concatenated with other files when embedded in Chrome)
var EventTracker = (function() {
  'use strict';

  /**
   *  Create an EventTracker to track a set of events.
   *  EventTracker instances are typically tied 1:1 with other objects or
   *  DOM elements whose listeners should be removed when the object is disposed
   *  or the corresponding elements are removed from the DOM.
   *  @constructor
   */
  function EventTracker() {
    /**
     *  @type {Array.<EventTracker.Entry>}
     *  @private
     */
    this.listeners_ = [];
  }

  /**
   * The type of the internal tracking entry.
   *  @typedef {{node: !Node,
   *            eventType: string,
   *            listener: Function,
   *            capture: boolean}}
   */
  EventTracker.Entry;

  EventTracker.prototype = {
    /**
     * Add an event listener - replacement for Node.addEventListener.
     * @param {!Node} node The DOM node to add a listener to.
     * @param {string} eventType The type of event to subscribe to.
     * @param {Function} listener The listener to add.
     * @param {boolean} capture Whether to invoke during the capture phase.
     */
    add: function(node, eventType, listener, capture) {
      var h = {
        node: node,
        eventType: eventType,
        listener: listener,
        capture: capture
      };
      this.listeners_.push(h);
      node.addEventListener(eventType, listener, capture);
    },

    /**
     * Remove any specified event listeners added with this EventTracker.
     * @param {!Node} node The DOM node to remove a listener from.
     * @param {string} eventType The type of event to remove.
     */
    remove: function(node, eventType) {
      this.listeners_ = this.listeners_.filter(function(h) {
        if (h.node == node && h.eventType == eventType) {
          EventTracker.removeEventListener_(h);
          return false;
        }
        return true;
      });
    },

    /**
     * Remove all event listeners added with this EventTracker.
     */
    removeAll: function() {
      this.listeners_.forEach(EventTracker.removeEventListener_);
      this.listeners_ = [];
    }
  };

  /**
   * Remove a single event listener given it's tracker entry.  It's up to the
   * caller to ensure the entry is removed from listeners_.
   * @param {EventTracker.Entry} h The entry describing the listener to remove.
   * @private
   */
  EventTracker.removeEventListener_ = function(h) {
    h.node.removeEventListener(h.eventType, h.listener, h.capture);
  };

  return EventTracker;
})();

</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    var elements;
    if (typeof source == 'string')
      elements = cr.doc.querySelectorAll(source);
    else
      elements = [source];

    for (var i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr))
        constr.decorate(el);
    }
  }

  /**
   * Helper function for creating new element for define.
   */
  function createElementHelper(tagName, opt_bag) {
    // Allow passing in ownerDocument to create in a different document.
    var doc;
    if (opt_bag && opt_bag.ownerDocument)
      doc = opt_bag.ownerDocument;
    else
      doc = cr.doc;
    return doc.createElement(tagName);
  }

  /**
   * Creates the constructor for a UI element class.
   *
   * Usage:
   * <pre>
   * var List = cr.ui.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   * </pre>
   *
   * @param {string|Function} tagNameOrFunction The tagName or
   *     function to use for newly created elements. If this is a function it
   *     needs to return a new element when called.
   * @return {function(Object=):Element} The constructor function which takes
   *     an optional property bag. The function also has a static
   *     {@code decorate} method added to it.
   */
  function define(tagNameOrFunction) {
    var createFunction, tagName;
    if (typeof tagNameOrFunction == 'function') {
      createFunction = tagNameOrFunction;
      tagName = '';
    } else {
      createFunction = createElementHelper;
      tagName = tagNameOrFunction;
    }

    /**
     * Creates a new UI element constructor.
     * @param {Object=} opt_propertyBag Optional bag of properties to set on the
     *     object after created. The property {@code ownerDocument} is special
     *     cased and it allows you to create the element in a different
     *     document than the default.
     * @constructor
     */
    function f(opt_propertyBag) {
      var el = createFunction(tagName, opt_propertyBag);
      f.decorate(el);
      for (var propertyName in opt_propertyBag) {
        el[propertyName] = opt_propertyBag[propertyName];
      }
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function(el) {
      el.__proto__ = f.prototype;
      el.decorate();
    };

    return f;
  }

  /**
   * Input elements do not grow and shrink with their content. This is a simple
   * (and not very efficient) way of handling shrinking to content with support
   * for min width and limited by the width of the parent element.
   * @param {HTMLElement} el The element to limit the width for.
   * @param {number} parentEl The parent element that should limit the size.
   * @param {number} min The minimum width.
   */
  function limitInputWidth(el, parentEl, min) {
    // Needs a size larger than borders
    el.style.width = '10px';
    var doc = el.ownerDocument;
    var win = doc.defaultView;
    var computedStyle = win.getComputedStyle(el);
    var parentComputedStyle = win.getComputedStyle(parentEl);
    var rtl = computedStyle.direction == 'rtl';

    // To get the max width we get the width of the treeItem minus the position
    // of the input.
    var inputRect = el.getBoundingClientRect();  // box-sizing
    var parentRect = parentEl.getBoundingClientRect();
    var startPos = rtl ? parentRect.right - inputRect.right :
        inputRect.left - parentRect.left;

    // Add up border and padding of the input.
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +
        parseInt(computedStyle.paddingLeft, 10) +
        parseInt(computedStyle.paddingRight, 10) +
        parseInt(computedStyle.borderRightWidth, 10);

    // We also need to subtract the padding of parent to prevent it to overflow.
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :
        parseInt(parentComputedStyle.paddingRight, 10);

    var max = parentEl.clientWidth - startPos - inner - parentPadding;

    function limit() {
      if (el.scrollWidth > max) {
        el.style.width = max + 'px';
      } else {
        el.style.width = 0;
        var sw = el.scrollWidth;
        if (sw < min) {
          el.style.width = min + 'px';
        } else {
          el.style.width = sw + 'px';
        }
      }
    }

    el.addEventListener('input', limit);
    limit();
  }

  return {
    decorate: decorate,
    define: define,
    limitInputWidth: limitInputWidth
  };
});
</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview A command is an abstraction of an action a user can do in the
 * UI.
 *
 * When the focus changes in the document for each command a canExecute event
 * is dispatched on the active element. By listening to this event you can
 * enable and disable the command by setting the event.canExecute property.
 *
 * When a command is executed a command event is dispatched on the active
 * element. Note that you should stop the propagation after you have handled the
 * command if there might be other command listeners higher up in the DOM tree.
 */

cr.define('cr.ui', function() {

  /**
   * This is used to identify keyboard shortcuts.
   * @param {string} shortcut The text used to describe the keys for this
   *     keyboard shortcut.
   * @constructor
   */
  function KeyboardShortcut(shortcut) {
    var mods = {};
    var ident = '';
    shortcut.split('-').forEach(function(part) {
      var partLc = part.toLowerCase();
      switch (partLc) {
        case 'alt':
        case 'ctrl':
        case 'meta':
        case 'shift':
          mods[partLc + 'Key'] = true;
          break;
        default:
          if (ident)
            throw Error('Invalid shortcut');
          ident = part;
      }
    });

    this.ident_ = ident;
    this.mods_ = mods;
  }

  KeyboardShortcut.prototype = {
    /**
     * Wether the keyboard shortcut object mathes a keyboard event.
     * @param {!Event} e The keyboard event object.
     * @return {boolean} Whether we found a match or not.
     */
    matchesEvent: function(e) {
      if (e.keyIdentifier == this.ident_) {
        // All keyboard modifiers needs to match.
        var mods = this.mods_;
        return ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].every(function(k) {
          return e[k] == !!mods[k];
        });
      }
      return false;
    }
  };

  /**
   * Creates a new command element.
   * @constructor
   * @extends {HTMLElement}
   */
  var Command = cr.ui.define('command');

  Command.prototype = {
    __proto__: HTMLElement.prototype,

    /**
     * Initializes the command.
     */
    decorate: function() {
      CommandManager.init(this.ownerDocument);
    },

    /**
     * Executes the command. This dispatches a command event on the active
     * element. If the command is {@code disabled} this does nothing.
     */
    execute: function() {
      if (this.disabled)
        return;
      var doc = this.ownerDocument;
      if (doc.activeElement) {
        var e = new cr.Event('command', true, false);
        e.command = this;
        doc.activeElement.dispatchEvent(e);
      }
    },

    /**
     * Call this when there have been changes that might change whether the
     * command can be executed or not.
     */
    canExecuteChange: function() {
      dispatchCanExecuteEvent(this, this.ownerDocument.activeElement);
    },

    /**
     * The keyboard shortcut that triggers the command. This is a string
     * consisting of a keyIdentifier (as reported by WebKit in keydown) as
     * well as optional key modifiers joinded with a '-'.
     *
     * Multiple keyboard shortcuts can be provided by separating them by
     * whitespace.
     *
     * For example:
     *   "F1"
     *   "U+0008-Meta" for Apple command backspace.
     *   "U+0041-Ctrl" for Control A
     *   "U+007F U+0008-Meta" for Delete and Command Backspace
     *
     * @type {string}
     */
    shortcut_: '',
    get shortcut() {
      return this.shortcut_;
    },
    set shortcut(shortcut) {
      var oldShortcut = this.shortcut_;
      if (shortcut !== oldShortcut) {
        this.keyboardShortcuts_ = shortcut.split(/\s+/).map(function(shortcut) {
          return new KeyboardShortcut(shortcut);
        });

        // Set this after the keyboardShortcuts_ since that might throw.
        this.shortcut_ = shortcut;
        cr.dispatchPropertyChange(this, 'shortcut', this.shortcut_,
                                  oldShortcut);
      }
    },

    /**
     * Whether the event object matches the shortcut for this command.
     * @param {!Event} e The key event object.
     * @return {boolean} Whether it matched or not.
     */
    matchesEvent: function(e) {
      if (!this.keyboardShortcuts_)
        return false;

      return this.keyboardShortcuts_.some(function(keyboardShortcut) {
        return keyboardShortcut.matchesEvent(e);
        });
      }
  };

  /**
   * The label of the command.
   * @type {string}
   */
  cr.defineProperty(Command, 'label', cr.PropertyKind.ATTR);

  /**
   * Whether the command is disabled or not.
   * @type {boolean}
   */
  cr.defineProperty(Command, 'disabled', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the command is hidden or not.
   * @type {boolean}
   */
  cr.defineProperty(Command, 'hidden', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the command is checked or not.
   * @type {boolean}
   */
  cr.defineProperty(Command, 'checked', cr.PropertyKind.BOOL_ATTR);

  /**
   * Dispatches a canExecute event on the target.
   * @param {cr.ui.Command} command The command that we are testing for.
   * @param {Element} target The target element to dispatch the event on.
   */
  function dispatchCanExecuteEvent(command, target) {
    var e = new CanExecuteEvent(command, true)
    target.dispatchEvent(e);
    command.disabled = !e.canExecute;
  }

  /**
   * The command managers for different documents.
   */
  var commandManagers = {};

  /**
   * Keeps track of the focused element and updates the commands when the focus
   * changes.
   * @param {!Document} doc The document that we are managing the commands for.
   * @constructor
   */
  function CommandManager(doc) {
    doc.addEventListener('focus', this.handleFocus_.bind(this), true);
    // Make sure we add the listener to the bubbling phase so that elements can
    // prevent the command.
    doc.addEventListener('keydown', this.handleKeyDown_.bind(this), false);
  }

  /**
   * Initializes a command manager for the document as needed.
   * @param {!Document} doc The document to manage the commands for.
   */
  CommandManager.init = function(doc) {
    var uid = cr.getUid(doc);
    if (!(uid in commandManagers)) {
      commandManagers[uid] = new CommandManager(doc);
    }
  },

  CommandManager.prototype = {

    /**
     * Handles focus changes on the document.
     * @param {Event} e The focus event object.
     * @private
     */
    handleFocus_: function(e) {
      var target = e.target;
      var commands = Array.prototype.slice.call(
          target.ownerDocument.querySelectorAll('command'));

      commands.forEach(function(command) {
        dispatchCanExecuteEvent(command, target);
      });
    },

    /**
     * Handles the keydown event and routes it to the right command.
     * @param {!Event} e The keydown event.
     */
    handleKeyDown_: function(e) {
      var target = e.target;
      var commands = Array.prototype.slice.call(
          target.ownerDocument.querySelectorAll('command'));

      for (var i = 0, command; command = commands[i]; i++) {
        if (!command.disabled && command.matchesEvent(e)) {
          e.preventDefault();
          // We do not want any other element to handle this.
          e.stopPropagation();

          command.execute();
          return;
        }
      }
    }
  };

  /**
   * The event type used for canExecute events.
   * @param {!cr.ui.Command} command The command that we are evaluating.
   * @extends {Event}
   */
  function CanExecuteEvent(command) {
    var e = command.ownerDocument.createEvent('Event');
    e.initEvent('canExecute', true, false);
    e.__proto__ = CanExecuteEvent.prototype;
    e.command = command;
    return e;
  }

  CanExecuteEvent.prototype = {
    __proto__: Event.prototype,

    /**
     * The current command
     * @type {cr.ui.Command}
     */
    command: null,

    /**
     * Whether the target can execute the command. Setting this also stops the
     * propagation.
     * @type {boolean}
     */
    canExecute_: false,
    get canExecute() {
      return this.canExecute_;
    },
    set canExecute(canExecute) {
      this.canExecute_ = !!canExecute;
      this.stopPropagation();
    }
  };

  // Export
  return {
    Command: Command,
    CanExecuteEvent: CanExecuteEvent
  };
});
</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  const Command = cr.ui.Command;

  /**
   * Creates a new menu item element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var MenuItem = cr.ui.define('div');

  /**
   * Creates a new menu separator element.
   * @return {cr.ui.MenuItem}
   */
  MenuItem.createSeparator = function() {
    var el = cr.doc.createElement('hr');
    MenuItem.decorate(el);
    return el;
  };

  MenuItem.prototype = {
    __proto__: HTMLButtonElement.prototype,

    /**
     * Initializes the menu item.
     */
    decorate: function() {
      var commandId;
      if ((commandId = this.getAttribute('command')))
        this.command = commandId;

      this.addEventListener('mouseup', this.handleMouseUp_);
    },

    /**
     * The command associated with this menu item. If this is set to a string
     * of the form "#element-id" then the element is looked up in the document
     * of the command.
     * @type {cr.ui.Command}
     */
    command_: null,
    get command() {
      return this.command_;
    },
    set command(command) {
      if (this.command_) {
        this.command_.removeEventListener('labelChange', this);
        this.command_.removeEventListener('disabledChange', this);
        this.command_.removeEventListener('hiddenChange', this);
        this.command_.removeEventListener('checkedChange', this);
      }

      if (typeof command == 'string' && command[0] == '#') {
        command = this.ownerDocument.getElementById(command.slice(1));
        cr.ui.decorate(command, Command);
      }

      this.command_ = command;
      if (command) {
        if (command.id)
          this.setAttribute('command', '#' + command.id);

        this.label = command.label;
        this.disabled = command.disabled;
        this.hidden = command.hidden;

        this.command_.addEventListener('labelChange', this);
        this.command_.addEventListener('disabledChange', this);
        this.command_.addEventListener('hiddenChange', this);
        this.command_.addEventListener('checkedChange', this);
      }
    },

    /**
     * The text label.
     * @type {string}
     */
    get label() {
      return this.textContent;
    },
    set label(label) {
      this.textContent = label;
    },

    /**
     * @return {boolean} Whether the menu item is a separator.
     */
    isSeparator: function() {
      return this.tagName == 'HR';
    },

    /**
     * Handles mouseup events. This dispatches an active event and if there
     * is an assiciated command then that is executed.
     * @param {Event} The mouseup event object.
     * @private
     */
    handleMouseUp_: function(e) {
      if (!this.disabled && !this.isSeparator()) {
        // Dispatch command event followed by executing the command object.
        if (cr.dispatchSimpleEvent(this, 'activate', true, true)) {
          var command = this.command;
          if (command)
            command.execute();
        }
      }
    },

    /**
     * Handles changes to the associated command.
     * @param {Event} e The event object.
     */
    handleEvent: function(e) {
      switch (e.type) {
        case 'disabledChange':
          this.disabled = this.command.disabled;
          break;
        case 'hiddenChange':
          this.hidden = this.command.hidden;
          break;
        case 'labelChange':
          this.label = this.command.label;
          break;
        case 'checkedChange':
          this.checked = this.command.checked;
          break;
      }
    }
  };

  /**
   * Whether the menu item is disabled or not.
   * @type {boolean}
   */
  cr.defineProperty(MenuItem, 'disabled', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is hidden or not.
   * @type {boolean}
   */
  cr.defineProperty(MenuItem, 'hidden', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is selected or not.
   * @type {boolean}
   */
  cr.defineProperty(MenuItem, 'selected', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is checked or not.
   * @type {boolean}
   */
  cr.defineProperty(MenuItem, 'checked', cr.PropertyKind.BOOL_ATTR);

  // Export
  return {
    MenuItem: MenuItem
  };
});
</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  const MenuItem = cr.ui.MenuItem;

  /**
   * Creates a new menu element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLMenuElement}
   */
  var Menu = cr.ui.define('menu');

  Menu.prototype = {
    __proto__: HTMLMenuElement.prototype,

    selectedIndex_: -1,

    /**
     * Initializes the menu element.
     */
    decorate: function() {
      this.addEventListener('mouseover', this.handleMouseOver_);
      this.addEventListener('mouseout', this.handleMouseOut_);

      // Decorate the children as menu items.
      var children = this.children;
      for (var i = 0, child; child = children[i]; i++) {
        cr.ui.decorate(child, MenuItem);
      }
    },

    /**
     * Walks up the ancestors until a menu item belonging to this menu is found.
     * @param {Element} el
     * @return {cr.ui.MenuItem} The found menu item or null.
     * @private
     */
    findMenuItem_: function(el) {
      while (el && el.parentNode != this) {
        el = el.parentNode;
      }
      return el;
    },

    /**
     * Handles mouseover events and selects the hovered item.
     * @param {Event} e The mouseover event.
     * @private
     */
    handleMouseOver_: function(e) {
      var overItem = this.findMenuItem_(e.target);
      this.selectedItem = overItem;
    },

    /**
     * Handles mouseout events and deselects any selected item.
     * @param {Event} e The mouseout event.
     * @private
     */
    handleMouseOut_: function(e) {
      this.selectedItem = null;
    },

    /**
     * The selected menu item or null if none.
     * @type {cr.ui.MenuItem}
     */
    get selectedItem() {
      return this.children[this.selectedIndex];
    },
    set selectedItem(item) {
      var index = Array.prototype.indexOf.call(this.children, item);
      this.selectedIndex = index;
    },

    /**
     * This is the function that handles keyboard navigation. This is usually
     * called by the element responsible for managing the menu.
     * @param {Event} e The keydown event object.
     * @return {boolean} Whether the event was handled be the menu.
     */
    handleKeyDown: function(e) {
      var item = this.selectedItem;

      var self = this;
      function selectNextVisible(m) {
        var children = self.children;
        var len = children.length;
        var i = self.selectedIndex;
        if (i == -1 && m == -1) {
          // Edge case when we need to go the last item fisrt.
          i = 0;
        }
        while (true) {
          i = (i + m + len) % len;
          item = children[i];
          if (item && !item.isSeparator() && !item.hidden)
            break;
        }
        if (item)
          self.selectedIndex = i;
      }

      switch (e.keyIdentifier) {
        case 'Down':
          selectNextVisible(1);
          return true;
        case 'Up':
          selectNextVisible(-1);
          return true;
        case 'Enter':
        case 'U+0020': // Space
          if (item) {
            if (cr.dispatchSimpleEvent(item, 'activate', true, true)) {
              if (item.command)
                item.command.execute();
            }
          }
          return true;
      }

      return false;
    }
  };

  function selectedIndexChanged(selectedIndex, oldSelectedIndex) {
    var oldSelectedItem = this.children[oldSelectedIndex];
    if (oldSelectedItem)
      oldSelectedItem.selected = false;
    var item = this.selectedItem;
    if (item)
      item.selected = true;
  }
  /**
   * The selected menu item.
   * @type {number}
   */
  cr.defineProperty(Menu, 'selectedIndex', cr.PropertyKind.JS,
      selectedIndexChanged);

  // Export
  return {
    Menu: Menu
  };
});
</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file provides utility functions for position popups.
 */

cr.define('cr.ui', function() {

  /**
   * Type def for rects as returned by getBoundingClientRect.
   * @typedef { {left: number, top: number, width: number, height: number,
   *             right: number, bottom: number}}
   */
  var Rect;

  /**
   * Enum for defining how to anchor a popup to an anchor element.
   * @enum {number}
   */
  const AnchorType = {
    /**
     * The popup's right edge is aligned with the left edge of the anchor.
     * The popup's top edge is aligned with the top edge of the anchor.
     */
    BEFORE: 1,  // p: right, a: left, p: top, a: top

    /**
     * The popop's left edge is aligned with the right edge of the anchor.
     * The popup's top edge is aligned with the top edge of the anchor.
     */
    AFTER: 2,  // p: left a: right, p: top, a: top

    /**
     * The popop's bottom edge is aligned with the top edge of the anchor.
     * The popup's left edge is aligned with the left edge of the anchor.
     */
    ABOVE: 3,  // p: bottom, a: top, p: left, a: left

    /**
     * The popop's top edge is aligned with the bottom edge of the anchor.
     * The popup's left edge is aligned with the left edge of the anchor.
     */
    BELOW: 4  // p: top, a: bottom, p: left, a: left
  };

  /**
   * Helper function for positionPopupAroundElement and positionPopupAroundRect.
   * @param {!Rect} anchorRect The rect for the anchor.
   * @param {!HTMLElement} popupElement The element used for the popup.
   * @param {AnchorType} type The type of anchoring to do.
   * @param {boolean} invertLeftRight Whether to invert the right/left
   *     alignment.
   */
  function positionPopupAroundRect(anchorRect, popupElement, type,
                                   invertLeftRight) {
    var popupRect = popupElement.getBoundingClientRect();
    var availRect;
    var ownerDoc = popupElement.ownerDocument;
    var cs = ownerDoc.defaultView.getComputedStyle(popupElement);
    var docElement = ownerDoc.documentElement;

    if (cs.position == 'fixed') {
      // For 'fixed' positioned popups, the available rectangle should be based
      // on the viewport rather than the document.
      availRect = {
        height: docElement.clientHeight,
        width: docElement.clientWidth,
        top: 0,
        bottom: docElement.clientHeight,
        left: 0,
        right: docElement.clientWidth
      };
    } else {
      availRect = popupElement.offsetParent.getBoundingClientRect();
    }

    if (cs.direction == 'rtl')
      invertLeftRight = !invertLeftRight;

    // Flip BEFORE, AFTER based on alignment.
    if (invertLeftRight) {
      if (type == AnchorType.BEFORE)
        type = AnchorType.AFTER;
      else if (type == AnchorType.AFTER)
        type = AnchorType.BEFORE;
    }

    // Flip type based on available size
    switch (type) {
      case AnchorType.BELOW:
        if (anchorRect.bottom + popupRect.height > availRect.height &&
            popupRect.height <= anchorRect.top) {
          type = AnchorType.ABOVE;
        }
        break;
      case AnchorType.ABOVE:
        if (popupRect.height > anchorRect.top &&
            anchorRect.bottom + popupRect.height <= availRect.height) {
          type = AnchorType.BELOW;
        }
        break;
      case AnchorType.AFTER:
        if (anchorRect.right + popupRect.width > availRect.width &&
            popupRect.width <= anchorRect.left) {
          type = AnchorType.BEFORE;
        }
        break;
      case AnchorType.BEFORE:
        if (popupRect.width > anchorRect.left &&
            anchorRect.right + popupRect.width <= availRect.width) {
          type = AnchorType.AFTER;
        }
        break;
    }
    // flipping done

    var style = popupElement.style;
    // Reset all directions.
    style.left = style.right = style.top = style.bottom = 'auto'

    // Primary direction
    switch (type) {
      case AnchorType.BELOW:
        if (anchorRect.bottom + popupRect.height <= availRect.height)
          style.top = anchorRect.bottom + 'px';
        else
          style.bottom = '0';
        break;
      case AnchorType.ABOVE:
        if (availRect.height - anchorRect.top >= 0)
          style.bottom = availRect.height - anchorRect.top + 'px';
        else
          style.top = '0';
        break;
      case AnchorType.AFTER:
        if (anchorRect.right + popupRect.width <= availRect.width)
          style.left = anchorRect.right + 'px';
        else
          style.right = '0';
        break;
      case AnchorType.BEFORE:
        if (availRect.width - anchorRect.left >= 0)
          style.right = availRect.width - anchorRect.left + 'px';
        else
          style.left = '0';
        break;
    }

    // Secondary direction
    switch (type) {
      case AnchorType.BELOW:
      case AnchorType.ABOVE:
        if (invertLeftRight) {
          // align right edges
          if (anchorRect.right - popupRect.width >= 0) {
            style.right = availRect.width - anchorRect.right + 'px';

          // align left edges
          } else if (anchorRect.left + popupRect.width <= availRect.width) {
            style.left = anchorRect.left + 'px';

          // not enough room on either side
          } else {
            style.right = '0';
          }
        } else {
          // align left edges
          if (anchorRect.left + popupRect.width <= availRect.width) {
            style.left = anchorRect.left + 'px';

          // align right edges
          } else if (anchorRect.right - popupRect.width >= 0) {
            style.right = availRect.width - anchorRect.right + 'px';

          // not enough room on either side
          } else {
            style.left = '0';
          }
        }
        break;

      case AnchorType.AFTER:
      case AnchorType.BEFORE:
        // align top edges
        if (anchorRect.top + popupRect.height <= availRect.height) {
          style.top = anchorRect.top + 'px';

        // align bottom edges
        } else if (anchorRect.bottom - popupRect.height >= 0) {
          style.bottom = availRect.height - anchorRect.bottom + 'px';

          // not enough room on either side
        } else {
          style.top = '0';
        }
        break;
    }
  }

  /**
   * Positions a popup element relative to an anchor element. The popup element
   * should have position set to absolute and it should be a child of the body
   * element.
   * @param {!HTMLElement} anchorElement The element that the popup is anchored
   *     to.
   * @param {!HTMLElement} popupElement The popup element we are positioning.
   * @param {AnchorType} type The type of anchoring we want.
   * @param {boolean} invertLeftRight Whether to invert the right/left
   *     alignment.
   */
  function positionPopupAroundElement(anchorElement, popupElement, type,
                                      invertLeftRight) {
    var anchorRect = anchorElement.getBoundingClientRect();
    positionPopupAroundRect(anchorRect, popupElement, type, invertLeftRight);
  }

  /**
   * Positions a popup around a point.
   * @param {number} x The client x position.
   * @param {number} y The client y position.
   * @param {!HTMLElement} popupElement The popup element we are positioning.
   */
  function positionPopupAtPoint(x, y, popupElement) {
    var rect = {
      left: x,
      top: y,
      width: 0,
      height: 0,
      right: x,
      bottom: y
    };
    positionPopupAroundRect(rect, popupElement, AnchorType.BELOW);
  }

  // Export
  return {
    AnchorType: AnchorType,
    positionPopupAroundElement: positionPopupAroundElement,
    positionPopupAtPoint: positionPopupAtPoint
  };
});
</script>
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  const Menu = cr.ui.Menu;
  const positionPopupAroundElement = cr.ui.positionPopupAroundElement;

  /**
   * Creates a new menu button element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLButtonElement}
   */
  var MenuButton = cr.ui.define('button');

  MenuButton.prototype = {
    __proto__: HTMLButtonElement.prototype,

    /**
     * Initializes the menu button.
     */
    decorate: function() {
      this.addEventListener('mousedown', this);
      this.addEventListener('keydown', this);

      var menu;
      if ((menu = this.getAttribute('menu')))
        this.menu = menu;

      // An event tracker for events we only connect to while the menu is
      // displayed.
      this.showingEvents_ = new EventTracker();

      this.anchorType = cr.ui.AnchorType.BELOW;
      this.invertLeftRight = false;
    },

    /**
     * The menu associated with the menu button.
     * @type {cr.ui.Menu}
     */
    get menu() {
      return this.menu_;
    },
    set menu(menu) {
      if (typeof menu == 'string' && menu[0] == '#') {
        menu = this.ownerDocument.getElementById(menu.slice(1));
        cr.ui.decorate(menu, Menu);
      }

      this.menu_ = menu;
      if (menu) {
        if (menu.id)
          this.setAttribute('menu', '#' + menu.id);
      }
    },

    /**
     * Handles event callbacks.
     * @param {Event} e The event object.
     */
    handleEvent: function(e) {
      if (!this.menu)
        return;

      switch (e.type) {
        case 'mousedown':
          if (e.currentTarget == this.ownerDocument) {
            if (!this.contains(e.target) && !this.menu.contains(e.target))
              this.hideMenu();
            else
              e.preventDefault();
          } else {
            if (this.isMenuShown()) {
              this.hideMenu();
            } else if (e.button == 0) {  // Only show the menu when using left
                                         // mouse button.
              this.showMenu();
              // Prevent the button from stealing focus on mousedown.
              e.preventDefault();
            }
          }
          break;
        case 'keydown':
          this.handleKeyDown(e);
          // If the menu is visible we let it handle all the keyboard events.
          if (this.isMenuShown() && e.currentTarget == this.ownerDocument) {
            this.menu.handleKeyDown(e);
            e.preventDefault();
            e.stopPropagation();
          }
          break;

        case 'activate':
        case 'blur':
        case 'resize':
          this.hideMenu();
          break;
      }
    },

    /**
     * Shows the menu.
     */
    showMenu: function() {
      this.hideMenu();

      this.menu.style.display = 'block';
      this.setAttribute('menu-shown', '');

      // when the menu is shown we steal all keyboard events.
      var doc = this.ownerDocument;
      var win = doc.defaultView;
      this.showingEvents_.add(doc, 'keydown', this, true);
      this.showingEvents_.add(doc, 'mousedown', this, true);
      this.showingEvents_.add(doc, 'blur', this, true);
      this.showingEvents_.add(win, 'resize', this);
      this.showingEvents_.add(this.menu, 'activate', this);
      this.positionMenu_();
    },

    /**
     * Hides the menu. If your menu can go out of scope, make sure to call this
     * first.
     */
    hideMenu: function() {
      if (!this.isMenuShown())
        return;

      this.removeAttribute('menu-shown');
      this.menu.style.display = 'none';

      this.showingEvents_.removeAll();
      this.menu.selectedIndex = -1;
    },

    /**
     * Whether the menu is shown.
     */
    isMenuShown: function() {
      return this.hasAttribute('menu-shown');
    },

    /**
     * Positions the menu below the menu button. At this point we do not use any
     * advanced positioning logic to ensure the menu fits in the viewport.
     * @private
     */
    positionMenu_: function() {
      positionPopupAroundElement(this, this.menu, this.anchorType,
                                 this.invertLeftRight);
    },

    /**
     * Handles the keydown event for the menu button.
     */
    handleKeyDown: function(e) {
      switch (e.keyIdentifier) {
        case 'Down':
        case 'Up':
        case 'Enter':
        case 'U+0020': // Space
          if (!this.isMenuShown())
            this.showMenu();
          e.preventDefault();
          break;
        case 'Esc':
        case 'U+001B': // Maybe this is remote desktop playing a prank?
          this.hideMenu();
          break;
      }
    }
  };

  // Export
  return {
    MenuButton: MenuButton
  };
});
</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This implements a special button that is useful for showing a
 * context menu.
 */

cr.define('cr.ui', function() {
  const MenuButton = cr.ui.MenuButton;

  /**
   * Helper function for ContextMenuButton to find the first ancestor of the
   * button that has a context menu.
   * @param {!MenuButton} el The button to start the search from.
   * @return {HTMLElement} The found element or null if not found.
   */
  function getContextMenuTarget(el) {
    do {
      el = el.parentNode;
    } while (el && !('contextMenu' in el));
    return el;
  }

  /**
   * Creates a new menu button which is used to show the context menu for an
   * ancestor that has a {@code contextMenu} property.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {MenuButton}
   */
  var ContextMenuButton = cr.ui.define('button');

  ContextMenuButton.prototype = {
    __proto__: MenuButton.prototype,

    /**
     * Override to return the contextMenu for the ancestor.
     * @override
     * @type {cr.ui.Menu}
     */
    get menu() {
      var target = getContextMenuTarget(this);
      return target && target.contextMenu;
    },

    /** @inheritDoc */
    decorate: function() {
      this.tabIndex = -1;
      this.addEventListener('mouseup', this);
      MenuButton.prototype.decorate.call(this);
    },

    /** @inheritDoc */
    handleEvent: function(e) {
      switch (e.type) {
        case 'mousedown':
          // Menu buttons prevent focus changes.
          var target = getContextMenuTarget(this);
          if (target)
            target.focus();
          break;
        case 'mouseup':
          // Stop mouseup to prevent selection changes.
          e.stopPropagation();
          break;
      }
      MenuButton.prototype.handleEvent.call(this, e);
    }
  };

  // Export
  return {
    ContextMenuButton: ContextMenuButton
  };
});
</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  const positionPopupAtPoint = cr.ui.positionPopupAtPoint;
  const Menu = cr.ui.Menu;

  /**
   * Handles context menus.
   * @constructor
   */
  function ContextMenuHandler() {}

  ContextMenuHandler.prototype = {

    /**
     * The menu that we are currently showing.
     * @type {cr.ui.Menu}
     */
    menu_: null,
    get menu() {
      return this.menu_;
    },

    /**
     * Shows a menu as a context menu.
     * @param {!Event} e The event triggering the show (usally a contextmenu
     *     event).
     * @param {!cr.ui.Menu} menu The menu to show.
     */
    showMenu: function(e, menu) {
      this.menu_ = menu;

      menu.style.display = 'block';
      // when the menu is shown we steal all keyboard events.
      var doc = menu.ownerDocument;
      doc.addEventListener('keydown', this, true);
      doc.addEventListener('mousedown', this, true);
      doc.addEventListener('blur', this, true);
      doc.defaultView.addEventListener('resize', this);
      menu.addEventListener('contextmenu', this);
      menu.addEventListener('activate', this);
      this.positionMenu_(e, menu);
    },

    /**
     * Hide the currently shown menu.
     */
    hideMenu: function() {
      var menu = this.menu;
      if (!menu)
        return;

      menu.style.display = 'none';
      var doc = menu.ownerDocument;
      doc.removeEventListener('keydown', this, true);
      doc.removeEventListener('mousedown', this, true);
      doc.removeEventListener('blur', this, true);
      doc.defaultView.removeEventListener('resize', this);
      menu.removeEventListener('contextmenu', this);
      menu.removeEventListener('activate', this);
      menu.selectedIndex = -1;
      this.menu_ = null;

      // On windows we might hide the menu in a right mouse button up and if
      // that is the case we wait some short period before we allow the menu
      // to be shown again.
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;
    },

    /**
     * Positions the menu
     * @param {!Event} e The event object triggering the showing.
     * @param {!cr.ui.Menu} menu The menu to position.
     * @private
     */
    positionMenu_: function(e, menu) {
      // TODO(arv): Handle scrolled documents when needed.

      var element = e.currentTarget;
      var x, y;
      // When the user presses the context menu key (on the keyboard) we need
      // to detect this.
      if (this.keyIsDown_) {
        var rect = element.getRectForContextMenu ?
                       element.getRectForContextMenu() :
                       element.getBoundingClientRect();
        var offset = Math.min(rect.width, rect.height) / 2;
        x = rect.left + offset;
        y = rect.top + offset;
      } else {
        x = e.clientX;
        y = e.clientY;
      }

      positionPopupAtPoint(x, y, menu);
    },

    /**
     * Handles event callbacks.
     * @param {!Event} e The event object.
     */
    handleEvent: function(e) {
      // Keep track of keydown state so that we can use that to determine the
      // reason for the contextmenu event.
      switch (e.type) {
        case 'keydown':
          this.keyIsDown_ = !e.ctrlKey && !e.altKey &&
              // context menu key or Shift-F10
              (e.keyCode == 93 && !e.shiftKey ||
               e.keyIdentifier == 'F10' && e.shiftKey);
          break;

        case 'keyup':
          this.keyIsDown_ = false;
          break;
      }

      // Context menu is handled even when we have no menu.
      if (e.type != 'contextmenu' && !this.menu)
        return;

      switch (e.type) {
        case 'mousedown':
          if (!this.menu.contains(e.target))
            this.hideMenu();
          else
            e.preventDefault();
          break;
        case 'keydown':
          // keyIdentifier does not report 'Esc' correctly
          if (e.keyCode == 27 /* Esc */) {
            this.hideMenu();

          // If the menu is visible we let it handle all the keyboard events.
          } else if (this.menu) {
            this.menu.handleKeyDown(e);
            e.preventDefault();
            e.stopPropagation();
          }
          break;

        case 'activate':
        case 'blur':
        case 'resize':
          this.hideMenu();
          break;

        case 'contextmenu':
          if ((!this.menu || !this.menu.contains(e.target)) &&
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))
            this.showMenu(e, e.currentTarget.contextMenu);
          e.preventDefault();
          // Don't allow elements further up in the DOM to show their menus.
          e.stopPropagation();
          break;
      }
    },

    /**
     * Adds a contextMenu property to an element or element class.
     * @param {!Element|!Function} element The element or class to add the
     *     contextMenu property to.
     */
    addContextMenuProperty: function(element) {
      if (typeof element == 'function')
        element = element.prototype;

      element.__defineGetter__('contextMenu', function() {
        return this.contextMenu_;
      });
      element.__defineSetter__('contextMenu', function(menu) {
        var oldContextMenu = this.contextMenu;

        if (typeof menu == 'string' && menu[0] == '#') {
          menu = this.ownerDocument.getElementById(menu.slice(1));
          cr.ui.decorate(menu, Menu);
        }

        if (menu === oldContextMenu)
          return;

        if (oldContextMenu && !menu) {
          this.removeEventListener('contextmenu', contextMenuHandler);
          this.removeEventListener('keydown', contextMenuHandler);
          this.removeEventListener('keyup', contextMenuHandler);
        }
        if (menu && !oldContextMenu) {
          this.addEventListener('contextmenu', contextMenuHandler);
          this.addEventListener('keydown', contextMenuHandler);
          this.addEventListener('keyup', contextMenuHandler);
        }

        this.contextMenu_ = menu;

        if (menu && menu.id)
          this.setAttribute('contextmenu', '#' + menu.id);

        cr.dispatchPropertyChange(this, 'contextMenu', menu, oldContextMenu);
      });

      if (!element.getRectForContextMenu) {
        /**
         * @return {!ClientRect} The rect to use for positioning the context
         *     menu when the context menu is not opened using a mouse position.
         */
        element.getRectForContextMenu = function() {
          return this.getBoundingClientRect();
        };
      }
    }
  };

  /**
   * The singleton context menu handler.
   * @type {!ContextMenuHandler}
   */
  var contextMenuHandler = new ContextMenuHandler;

  // Export
  return {
    contextMenuHandler: contextMenuHandler
  };
});
</script>

<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The delegate interface:
//   dragContainer -->
//         element containing the draggable items
//
//   transitionsDuration -->
//         length of time of transitions in ms
//
//   dragItem -->
//         get / set property containing the item being dragged
//
//   getItem(e) -->
//         get's the item that is under the mouse event |e|
//
//   canDropOn(coordinates) -->
//         returns true if the coordinates (relative to the drag container)
//         point to a valid place to drop an item
//
//   setDragPlaceholder(coordinates) -->
//         tells the delegate that the dragged item is currently above
//         the specified coordinates.
//
//   saveDrag(draggedItem) -->
//         tells the delegate that the drag is done. move the item to the
//         position last specified by setDragPlaceholder (e.g., commit changes).
//         draggedItem was the item being dragged.
//

// The distance, in px, that the mouse must move before initiating a drag.
var DRAG_THRESHOLD = 35;

function DragAndDropController(delegate) {
  this.delegate_ = delegate;

  // Install the 'mousedown' handler, the entry point to drag and drop.
  var el = this.delegate_.dragContainer;
  el.addEventListener('mousedown', this.handleMouseDown_.bind(this));
}

DragAndDropController.prototype = {
  isDragging_: false,
  startItem_: null,
  startItemXY_: null,
  startMouseXY_: null,
  mouseXY_: null,

  // Enables the handlers that are only active during a drag.
  enableHandlers_: function() {
    // Record references to the generated functions so we can
    // remove the listeners later.
    this.mouseMoveListener_ = this.handleMouseMove_.bind(this);
    this.mouseUpListener_ = this.handleMouseUp_.bind(this);
    this.scrollListener_ = this.handleScroll_.bind(this);

    document.addEventListener('mousemove', this.mouseMoveListener_, true);
    document.addEventListener('mouseup', this.mouseUpListener_, true);
    document.addEventListener('scroll', this.scrollListener_, true);
  },

  disableHandlers_: function() {
    document.removeEventListener('mousemove', this.mouseMoveListener_, true);
    document.removeEventListener('mouseup', this.mouseUpListener_, true);
    document.removeEventListener('scroll', this.scrollListener_, true);
  },

  isDragging: function() {
    return this.isDragging_;
  },

  distance_: function(p1, p2) {
    var x2 = Math.pow(p1.x - p2.x, 2);
    var y2 = Math.pow(p1.y - p2.y, 2);
    return Math.sqrt(x2 + y2);
  },

  // Shifts the client coordinates, |xy|, so they are relative to the top left
  // of the drag container.
  getCoordinates_: function(xy) {
    var rect = this.delegate_.dragContainer.getBoundingClientRect();
    var coordinates = {
      x: xy.x - rect.left,
      y: xy.y - rect.top
    };

    // If we're in an RTL language, reflect the coordinates so the delegate
    // doesn't need to worry about it.
    if (isRtl())
      coordinates.x = this.delegate_.dragContainer.offsetWidth - coordinates.x;

    return coordinates;
  },

  // Listen to mousedown to get the relative position of the cursor when
  // starting drag and drop.
  handleMouseDown_: function(e) {
    var item = this.delegate_.getItem(e);

    // This can't be a drag & drop event if it's not the left mouse button
    // or if the mouse is not above an item. We also bail out if the dragging
    // flag is still set (the flag remains around for a bit so that 'click'
    // event handlers can distinguish between a click and drag).
    if (!item || e.button != 0 || this.isDragging())
      return;

    this.startItem_ = item;
    this.startItemXY_ = {x: item.offsetLeft, y: item.offsetTop};
    this.startMouseXY_ = {x: e.clientX, y: e.clientY};
    this.startScrollXY_ = {x: window.scrollX, y: window.scrollY};

    this.enableHandlers_();
  },

  handleMouseMove_: function(e) {
    this.mouseXY_ = {x: e.clientX, y: e.clientY};

    if (this.isDragging()) {
      this.handleDrag_();
      return;
    }

    // Initiate the drag if the mouse has moved far enough.
    if (this.distance_(this.startMouseXY_, this.mouseXY_) >= DRAG_THRESHOLD)
      this.handleDragStart_();
  },

  handleMouseUp_: function() {
    this.handleDrop_();
  },

  handleScroll_: function(e) {
    if (this.isDragging())
      this.handleDrag_();
  },

  handleDragStart_: function() {
    // Use the item that the mouse was above when 'mousedown' fired.
    var item = this.startItem_;
    if (!item)
      return;

    this.isDragging_ = true;
    this.delegate_.dragItem = item;
    item.classList.add('dragging');
    item.style.zIndex = 2;
  },

  handleDragOver_: function() {
    var coordinates = this.getCoordinates_(this.mouseXY_);
    if (!this.delegate_.canDropOn(coordinates))
      return;

    this.delegate_.setDragPlaceholder(coordinates);
  },

  handleDrop_: function() {
    this.disableHandlers_();

    var dragItem = this.delegate_.dragItem;
    if (!dragItem)
      return;

    this.delegate_.dragItem = this.startItem_ = null;
    this.delegate_.saveDrag(dragItem);
    dragItem.classList.remove('dragging');

    setTimeout(function() {
      // Keep the flag around a little so other 'mouseup' and 'click'
      // listeners know the event is from a drag operation.
      this.isDragging_ = false;
      dragItem.style.zIndex = 0;
    }.bind(this), this.delegate_.transitionsDuration);
  },

  handleDrag_: function() {
    // Moves the drag item making sure that it is not displayed outside the
    // drag container.
    var dragItem = this.delegate_.dragItem;
    var dragContainer = this.delegate_.dragContainer;
    var rect = dragContainer.getBoundingClientRect();

    // First, move the item the same distance the mouse has moved.
    var x = this.startItemXY_.x + this.mouseXY_.x - this.startMouseXY_.x +
              window.scrollX - this.startScrollXY_.x;
    var y = this.startItemXY_.y + this.mouseXY_.y - this.startMouseXY_.y +
              window.scrollY - this.startScrollXY_.y;

    var w = this.delegate_.dimensions.width;
    var h = this.delegate_.dimensions.height;

    var offset = parseInt(getComputedStyle(dragContainer).marginLeft);

    // The position of the item is relative to the drag container. We
    // want to make sure that half of the item's width or height is within
    // the container.
    x = Math.max(x, - w / 2 - offset);
    x = Math.min(x, rect.width  + w / 2 - offset);

    y = Math.max(- h / 2, y);
    y = Math.min(y, rect.height - h / 2);

    dragItem.style.left = x + 'px';
    dragItem.style.top = y + 'px';

    // Update the layouts and positions based on the new drag location.
    this.handleDragOver_();

    this.delegate_.scrollPage(this.mouseXY_);
  }
};
</script>
<script>// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Dependencies that we should remove/formalize:
// util.js
//
// afterTransition
// chrome.send
// hideNotification
// isRtl
// localStrings
// logEvent
// showNotification


var MostVisited = (function() {

  function addPinnedUrl(item, index) {
    chrome.send('addPinnedURL', [item.url, item.title, item.faviconUrl || '',
                                 item.thumbnailUrl || '', String(index)]);
  }

  function getItem(el) {
    return findAncestorByClass(el, 'thumbnail-container');
  }

  function updatePinnedDom(el, pinned) {
    el.querySelector('.pin').title = localStrings.getString(pinned ?
        'unpinthumbnailtooltip' : 'pinthumbnailtooltip');
    if (pinned) {
      el.classList.add('pinned');
    } else {
      el.classList.remove('pinned');
    }
  }

  function getThumbnailIndex(el) {
    var nodes = el.parentNode.querySelectorAll('.thumbnail-container');
    return Array.prototype.indexOf.call(nodes, el);
  }

  function MostVisited(el, miniview, menu, useSmallGrid, visible) {
    this.element = el;
    this.miniview = miniview;
    this.menu = menu;
    this.useSmallGrid_ = useSmallGrid;
    this.visible_ = visible;

    this.createThumbnails_();
    this.applyMostVisitedRects_();

    el.addEventListener('click', this.handleClick_.bind(this));
    el.addEventListener('keydown', this.handleKeyDown_.bind(this));

    document.addEventListener('DOMContentLoaded',
                              this.ensureSmallGridCorrect.bind(this));

    // Commands
    document.addEventListener('command', this.handleCommand_.bind(this));
    document.addEventListener('canExecute', this.handleCanExecute_.bind(this));

    // DND
    el.addEventListener('dragstart', this.handleDragStart_.bind(this));
    el.addEventListener('dragenter', this.handleDragEnter_.bind(this));
    el.addEventListener('dragover', this.handleDragOver_.bind(this));
    el.addEventListener('dragleave', this.handleDragLeave_.bind(this));
    el.addEventListener('drop', this.handleDrop_.bind(this));
    el.addEventListener('dragend', this.handleDragEnd_.bind(this));
    el.addEventListener('drag', this.handleDrag_.bind(this));
    el.addEventListener('mousedown', this.handleMouseDown_.bind(this));
  }

  MostVisited.prototype = {
    togglePinned_: function(el) {
      var index = getThumbnailIndex(el);
      var item = this.data[index];
      item.pinned = !item.pinned;
      if (item.pinned) {
        addPinnedUrl(item, index);
      } else {
        chrome.send('removePinnedURL', [item.url]);
      }
      updatePinnedDom(el, item.pinned);
    },

    swapPosition_: function(source, destination) {
      var nodes = source.parentNode.querySelectorAll('.thumbnail-container');
      var sourceIndex = getThumbnailIndex(source);
      var destinationIndex = getThumbnailIndex(destination);
      swapDomNodes(source, destination);

      var sourceData = this.data[sourceIndex];
      addPinnedUrl(sourceData, destinationIndex);
      sourceData.pinned = true;
      updatePinnedDom(source, true);

      var destinationData = this.data[destinationIndex];
      // Only update the destination if it was pinned before.
      if (destinationData.pinned) {
        addPinnedUrl(destinationData, sourceIndex);
      }
      this.data[destinationIndex] = sourceData;
      this.data[sourceIndex] = destinationData;
    },

    updateSettingsLink: function(hasBlacklistedUrls) {
      if (hasBlacklistedUrls)
        $('most-visited-settings').classList.add('has-blacklist');
      else
        $('most-visited-settings').classList.remove('has-blacklist');
    },

    blacklist: function(el) {
      var self = this;
      var url = el.href;
      chrome.send('blacklistURLFromMostVisited', [url]);

      el.classList.add('hide');

      // Find the old item.
      var oldUrls = {};
      var oldIndex = -1;
      var oldItem;
      var data = this.data;
      for (var i = 0; i < data.length; i++) {
        if (data[i].url == url) {
          oldItem = data[i];
          oldIndex = i;
        }
        oldUrls[data[i].url] = true;
      }

      // Send 'getMostVisitedPages' with a callback since we want to find the
      // new page and add that in the place of the removed page.
      chromeSend('getMostVisited', [], 'setMostVisitedPages',
                 function(data, firstRun, hasBlacklistedUrls) {
        // Update settings link.
        self.updateSettingsLink(hasBlacklistedUrls);

        // Find new item.
        var newItem;
        for (var i = 0; i < data.length; i++) {
          if (!(data[i].url in oldUrls)) {
            newItem = data[i];
            break;
          }
        }

        if (!newItem) {
          // If no other page is available to replace the blacklisted item,
          // we need to reorder items s.t. all filler items are in the rightmost
          // indices.
          self.data = data;

        // Replace old item with new item in the most visited data array.
        } else if (oldIndex != -1) {
          var oldData = self.data.concat();
          oldData.splice(oldIndex, 1, newItem);
          self.data = oldData;
          el.classList.add('fade-in');
        }

        // We wrap the title in a <span class=blacklisted-title>. We pass an
        // empty string to the notifier function and use DOM to insert the real
        // string.
        var actionText = localStrings.getString('undothumbnailremove');

        // Show notification and add undo callback function.
        var wasPinned = oldItem.pinned;
        showNotification('', actionText, function() {
          self.removeFromBlackList(url);
          if (wasPinned) {
            addPinnedUrl(oldItem, oldIndex);
          }
          chrome.send('getMostVisited');
        });

        // Now change the DOM.
        var removeText = localStrings.getString('thumbnailremovednotification');
        var notifyMessageEl = document.querySelector('#notification > *');
        notifyMessageEl.textContent = removeText;

        // Focus the undo link.
        var undoLink = document.querySelector(
            '#notification > .link > [tabindex]');
        undoLink.focus();
      });
    },

    removeFromBlackList: function(url) {
      chrome.send('removeURLsFromMostVisitedBlacklist', [url]);
    },

    clearAllBlacklisted: function() {
      chrome.send('clearMostVisitedURLsBlacklist', []);
      hideNotification();
    },

    dirty_: false,
    invalidate_: function() {
      this.dirty_ = true;
    },

    visible_: true,
    get visible() {
      return this.visible_;
    },
    set visible(visible) {
      if (this.visible_ != visible) {
        this.visible_ = visible;
        this.invalidate_();
      }
    },

    useSmallGrid_: false,
    get useSmallGrid() {
      return this.useSmallGrid_;
    },
    set useSmallGrid(b) {
      if (this.useSmallGrid_ != b) {
        this.useSmallGrid_ = b;
        this.invalidate_();
      }
    },

    layout: function() {
      if (!this.dirty_)
        return;
      var d0 = Date.now();
      this.applyMostVisitedRects_();
      this.dirty_ = false;
      logEvent('mostVisited.layout: ' + (Date.now() - d0));
    },

    createThumbnails_: function() {
      var singleHtml =
          '<a class="thumbnail-container filler" tabindex="1">' +
            '<div class="edit-mode-border">' +
              '<div class="edit-bar">' +
                '<div class="pin"></div>' +
                '<div class="spacer"></div>' +
                '<div class="remove"></div>' +
              '</div>' +
              '<span class="thumbnail-wrapper">' +
                '<span class="thumbnail"></span>' +
              '</span>' +
            '</div>' +
            '<div class="title">' +
              '<div></div>' +
            '</div>' +
          '</a>';
      this.element.innerHTML = Array(8 + 1).join(singleHtml);
      var children = this.element.children;
      for (var i = 0; i < 8; i++) {
        children[i].id = 't' + i;
      }
    },

    getMostVisitedLayoutRects_: function() {
      var small = this.useSmallGrid;

      var cols = 4;
      var rows = 2;
      var marginWidth = 10;
      var marginHeight = 7;
      var borderWidth = 4;
      var thumbWidth = small ? 150 : 207;
      var thumbHeight = small ? 93 : 129;
      var w = thumbWidth + 2 * borderWidth + 2 * marginWidth;
      var h = thumbHeight + 40 + 2 * marginHeight;
      var sumWidth = cols * w  - 2 * marginWidth;
      var topSpacing = 10;

      var rtl = isRtl();
      var rects = [];

      if (this.visible) {
        for (var i = 0; i < rows * cols; i++) {
          var row = Math.floor(i / cols);
          var col = i % cols;
          var left = rtl ? sumWidth - col * w - thumbWidth - 2 * borderWidth :
              col * w;

          var top = row * h + topSpacing;

          rects[i] = {left: left, top: top};
        }
      }
      return rects;
    },

    applyMostVisitedRects_: function() {
      if (this.visible) {
        var rects = this.getMostVisitedLayoutRects_();
        var children = this.element.children;
        for (var i = 0; i < 8; i++) {
          var t = children[i];
          t.style.left = rects[i].left + 'px';
          t.style.top = rects[i].top + 'px';
          t.style.right = '';
          var innerStyle = t.firstElementChild.style;
          innerStyle.left = innerStyle.top = '';
        }
      }
    },

    // Work around for http://crbug.com/25329
    ensureSmallGridCorrect: function(expected) {
      if (expected != this.useSmallGrid)
        this.applyMostVisitedRects_();
    },

    getRectByIndex_: function(index) {
      return this.getMostVisitedLayoutRects_()[index];
    },

    // Commands

    handleCommand_: function(e) {
      var commandId = e.command.id;
      switch (commandId) {
        case 'clear-all-blacklisted':
          this.clearAllBlacklisted();
          chrome.send('getMostVisited');
          break;
      }
    },

    handleCanExecute_: function(e) {
      if (e.command.id == 'clear-all-blacklisted')
        e.canExecute = true;
    },

    // DND

    currentOverItem_: null,
    get currentOverItem() {
      return this.currentOverItem_;
    },
    set currentOverItem(item) {
      var style;
      if (item != this.currentOverItem_) {
        if (this.currentOverItem_) {
          style = this.currentOverItem_.firstElementChild.style;
          style.left = style.top = '';
        }
        this.currentOverItem_ = item;

        if (item) {
          // Make the drag over item move 15px towards the source. The movement
          // is done by only moving the edit-mode-border (as in the mocks) and
          // it is done with relative positioning so that the movement does not
          // change the drop target.
          var dragIndex = getThumbnailIndex(this.dragItem_);
          var overIndex = getThumbnailIndex(item);
          if (dragIndex == -1 || overIndex == -1) {
            return;
          }

          var dragRect = this.getRectByIndex_(dragIndex);
          var overRect = this.getRectByIndex_(overIndex);

          var x = dragRect.left - overRect.left;
          var y = dragRect.top - overRect.top;
          var z = Math.sqrt(x * x + y * y);
          var z2 = 15;
          var x2 = x * z2 / z;
          var y2 = y * z2 / z;

          style = this.currentOverItem_.firstElementChild.style;
          style.left = x2 + 'px';
          style.top = y2 + 'px';
        }
      }
    },
    dragItem_: null,
    startX_: 0,
    startY_: 0,
    startScreenX_: 0,
    startScreenY_: 0,
    dragEndTimer_: null,

    isDragging: function() {
      return !!this.dragItem_;
    },

    handleDragStart_: function(e) {
      var thumbnail = getItem(e.target);
      if (thumbnail) {
        // Don't set data since HTML5 does not allow setting the name for
        // url-list. Instead, we just rely on the dragging of link behavior.
        this.dragItem_ = thumbnail;
        this.dragItem_.classList.add('dragging');
        this.dragItem_.style.zIndex = 2;
        e.dataTransfer.effectAllowed = 'copyLinkMove';
      }
    },

    handleDragEnter_: function(e) {
      if (this.canDropOnElement_(this.currentOverItem)) {
        e.preventDefault();
      }
    },

    handleDragOver_: function(e) {
      var item = getItem(e.target);
      this.currentOverItem = item;
      if (this.canDropOnElement_(item)) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }
    },

    handleDragLeave_: function(e) {
      var item = getItem(e.target);
      if (item) {
        e.preventDefault();
      }

      this.currentOverItem = null;
    },

    handleDrop_: function(e) {
      var dropTarget = getItem(e.target);
      if (this.canDropOnElement_(dropTarget)) {
        dropTarget.style.zIndex = 1;
        this.swapPosition_(this.dragItem_, dropTarget);
        // The timeout below is to allow WebKit to see that we turned off
        // pointer-event before moving the thumbnails so that we can get out of
        // hover mode.
        window.setTimeout((function() {
          this.invalidate_();
          this.layout();
        }).bind(this), 10);
        e.preventDefault();
        if (this.dragEndTimer_) {
          window.clearTimeout(this.dragEndTimer_);
          this.dragEndTimer_ = null;
        }
        afterTransition(function() {
          dropTarget.style.zIndex = '';
        });
      }
    },

    handleDragEnd_: function(e) {
      var dragItem = this.dragItem_;
      if (dragItem) {
        dragItem.style.pointerEvents = '';
        dragItem.classList.remove('dragging');

        afterTransition(function() {
          // Delay resetting zIndex to let the animation finish.
          dragItem.style.zIndex = '';
          // Same for overflow.
          dragItem.parentNode.style.overflow = '';
        });

        this.invalidate_();
        this.layout();
        this.dragItem_ = null;
      }
    },

    handleDrag_: function(e) {
      // Moves the drag item making sure that it is not displayed outside the
      // browser viewport.
      var item = getItem(e.target);
      var rect = this.element.getBoundingClientRect();
      item.style.pointerEvents = 'none';

      var x = this.startX_ + e.screenX - this.startScreenX_;
      var y = this.startY_ + e.screenY - this.startScreenY_;

      // The position of the item is relative to #most-visited so we need to
      // subtract that when calculating the allowed position.
      x = Math.max(x, -rect.left);
      x = Math.min(x, document.body.clientWidth - rect.left - item.offsetWidth -
                   2);
      // The shadow is 2px
      y = Math.max(-rect.top, y);
      y = Math.min(y, document.body.clientHeight - rect.top -
                   item.offsetHeight - 2);

      // Override right in case of RTL.
      item.style.right = 'auto';
      item.style.left = x + 'px';
      item.style.top = y + 'px';
      item.style.zIndex = 2;
    },

    // We listen to mousedown to get the relative position of the cursor for
    // dnd.
    handleMouseDown_: function(e) {
      var item = getItem(e.target);
      if (item) {
        this.startX_ = item.offsetLeft;
        this.startY_ = item.offsetTop;
        this.startScreenX_ = e.screenX;
        this.startScreenY_ = e.screenY;

        // We don't want to focus the item on mousedown. However, to prevent
        // focus one has to call preventDefault but this also prevents the drag
        // and drop (sigh) so we only prevent it when the user is not doing a
        // left mouse button drag.
        if (e.button != 0) // LEFT
          e.preventDefault();
      }
    },

    canDropOnElement_: function(el) {
      return this.dragItem_ && el &&
          el.classList.contains('thumbnail-container') &&
          !el.classList.contains('filler');
    },


    /// data

    data_: null,
    get data() {
      return this.data_;
    },
    set data(data) {
      // We append the class name with the "filler" so that we can style fillers
      // differently.
      var maxItems = 8;
      data.length = Math.min(maxItems, data.length);
      var len = data.length;
      for (var i = len; i < maxItems; i++) {
        data[i] = {filler: true};
      }

      // On setting we need to update the items
      this.data_ = data;
      this.updateMostVisited_();
      this.updateMiniview_();
      this.updateMenu_();
    },

    updateMostVisited_: function() {

      function getThumbnailClassName(item) {
        return 'thumbnail-container' +
            (item.pinned ? ' pinned' : '') +
            (item.filler ? ' filler' : '');
      }

      var data = this.data;
      var children = this.element.children;
      for (var i = 0; i < data.length; i++) {
        var d = data[i];
        var t = children[i];

        // If we have a filler continue
        var oldClassName = t.className;
        var newClassName = getThumbnailClassName(d);
        if (oldClassName != newClassName) {
          t.className = newClassName;
        }

        // No need to continue if this is a filler.
        if (newClassName == 'thumbnail-container filler') {
          // Make sure the user cannot tab to the filler.
          t.tabIndex = -1;
          t.querySelector('.thumbnail-wrapper').style.backgroundImage = '';
          continue;
        }
        // Allow focus.
        t.tabIndex = 1;

        t.href = d.url;
        t.setAttribute('ping',
            getAppPingUrl('PING_BY_URL', d.url, 'NTP_MOST_VISITED'));
        t.querySelector('.pin').title = localStrings.getString(d.pinned ?
            'unpinthumbnailtooltip' : 'pinthumbnailtooltip');
        t.querySelector('.remove').title =
            localStrings.getString('removethumbnailtooltip');

        // There was some concern that a malformed malicious URL could cause an
        // XSS attack but setting style.backgroundImage = 'url(javascript:...)'
        // does not execute the JavaScript in WebKit.

        var thumbnailUrl = d.thumbnailUrl || 'chrome://thumb/' + d.url;
        t.querySelector('.thumbnail-wrapper').style.backgroundImage =
            url(thumbnailUrl);
        var titleDiv = t.querySelector('.title > div');
        titleDiv.xtitle = titleDiv.textContent = d.title;
        var faviconUrl = d.faviconUrl || 'chrome://favicon/' + d.url;
        titleDiv.style.backgroundImage = url(faviconUrl);
        titleDiv.dir = d.direction;
      }
    },

    updateMiniview_: function() {
      this.miniview.textContent = '';
      var data = this.data.slice(0, MAX_MINIVIEW_ITEMS);
      for (var i = 0, item; item = data[i]; i++) {
        if (item.filler) {
          continue;
        }

        var span = document.createElement('span');
        var a = span.appendChild(document.createElement('a'));
        a.href = item.url;
        a.setAttribute('ping',
            getAppPingUrl('PING_BY_URL', item.url, 'NTP_MOST_VISITED'));
        a.textContent = item.title;
        a.style.backgroundImage = url('chrome://favicon/' + item.url);
        a.className = 'item';
        this.miniview.appendChild(span);
      }
      updateMiniviewClipping(this.miniview);
    },

    updateMenu_: function() {
      clearClosedMenu(this.menu);
      var data = this.data.slice(0, MAX_MINIVIEW_ITEMS);
      for (var i = 0, item; item = data[i]; i++) {
        if (!item.filler) {
          addClosedMenuEntry(
              this.menu, item.url, item.title, 'chrome://favicon/' + item.url,
              getAppPingUrl('PING_BY_URL', item.url, 'NTP_MOST_VISITED'));
        }
      }
      addClosedMenuFooter(
          this.menu, 'most-visited', MENU_THUMB, Section.THUMB);
    },

    handleClick_: function(e) {
      var target = e.target;
      if (target.classList.contains('pin')) {
        this.togglePinned_(getItem(target));
        e.preventDefault();
      } else if (target.classList.contains('remove')) {
        this.blacklist(getItem(target));
        e.preventDefault();
      } else {
        var item = getItem(target);
        if (item) {
          var index = Array.prototype.indexOf.call(item.parentNode.children,
                                                   item);
          if (index != -1)
            chrome.send('metrics', ['NTP_MostVisited' + index]);
        }
      }
    },

    /**
     * Allow blacklisting most visited site using the keyboard.
     */
    handleKeyDown_: function(e) {
      if (!IS_MAC && e.keyCode == 46 || // Del
          IS_MAC && e.metaKey && e.keyCode == 8) { // Cmd + Backspace
        this.blacklist(e.target);
      }
    }
  };

  return MostVisited;
})();
</script>
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// To avoid creating tons of unnecessary nodes. We assume we cannot fit more
// than this many items in the miniview.
var MAX_MINIVIEW_ITEMS = 15;

// Extra spacing at the top of the layout.
var LAYOUT_SPACING_TOP = 25;

// The visible height of the expanded maxiview.
var maxiviewVisibleHeight = 0;

var APP_LAUNCH = {
  // The histogram buckets (keep in sync with extension_constants.h).
  NTP_APPS_MAXIMIZED: 0,
  NTP_APPS_COLLAPSED: 1,
  NTP_APPS_MENU: 2,
  NTP_MOST_VISITED: 3,
  NTP_RECENTLY_CLOSED: 4,
  NTP_APP_RE_ENABLE: 16
};

var APP_LAUNCH_URL = {
  // The URL prefix for pings that record app launches by URL.
  PING_BY_URL: 'record-app-launch-by-url',

  // The URL prefix for pings that record app launches by ID.
  PING_BY_ID: 'record-app-launch-by-id',

  // The URL prefix used by the webstore link 'ping' attributes.
  PING_WEBSTORE: 'record-webstore-launch'
};

function getAppPingUrl(prefix, data, bucket) {
  return [APP_LAUNCH_URL[prefix],
          encodeURIComponent(data),
          APP_LAUNCH[bucket]].join('+');
}

function getSectionCloseButton(sectionId) {
  return document.querySelector('#' + sectionId + ' .section-close-button');
}

function getSectionMenuButton(sectionId) {
  return $(sectionId + '-button');
}

function getSectionMenuButtonTextId(sectionId) {
  return sectionId.replace(/-/g, '');
}

function setSectionMenuMode(sectionId, section, menuModeEnabled, menuModeMask) {
  var el = $(sectionId);
  if (!menuModeEnabled) {
    // Because sections are collapsed when they are in menu mode, it is not
    // necessary to restore the maxiview here. It will happen if the section
    // header is clicked.
    // TODO(aa): Sections should maintain their collapse state when minimized.
    el.classList.remove('menu');
    shownSections &= ~menuModeMask;
  } else {
    if (section) {
      hideSection(section);  // To hide the maxiview.
    }
    el.classList.add('menu');
    shownSections |= menuModeMask;
  }
  layoutSections();
}

function clearClosedMenu(menu) {
  menu.innerHTML = '';
}

function addClosedMenuEntryWithLink(menu, a) {
  var span = document.createElement('span');
  a.className += ' item menuitem';
  span.appendChild(a);
  menu.appendChild(span);
}

function addClosedMenuEntry(menu, url, title, imageUrl, opt_pingUrl) {
  var a = document.createElement('a');
  a.href = url;
  a.textContent = title;
  a.style.backgroundImage = 'url(' + imageUrl + ')';
  if (opt_pingUrl)
    a.ping = opt_pingUrl;
  addClosedMenuEntryWithLink(menu, a);
}

function addClosedMenuFooter(menu, sectionId, mask, opt_section) {
  menu.appendChild(document.createElement('hr'));

  var span = document.createElement('span');
  var a = span.appendChild(document.createElement('a'));
  a.href = '';
  if (cr.isChromeOS) {
    a.textContent = localStrings.getString('expandMenu');
  } else {
    a.textContent =
        localStrings.getString(getSectionMenuButtonTextId(sectionId));
  }
  a.className = 'item';
  a.addEventListener(
      'click',
      function(e) {
        getSectionMenuButton(sectionId).hideMenu();
        e.preventDefault();
        setSectionMenuMode(sectionId, opt_section, false, mask);
        shownSections &= ~mask;
        saveShownSections();
      });
  menu.appendChild(span);
}

function initializeSection(sectionId, mask, opt_section) {
  var button = getSectionCloseButton(sectionId);
  button.addEventListener(
    'click',
    function() {
      setSectionMenuMode(sectionId, opt_section, true, mask);
      saveShownSections();
    });
}

function updateSimpleSection(id, section) {
  var elm = $(id);
  var maxiview = getSectionMaxiview(elm);
  var miniview = getSectionMiniview(elm);
  if (shownSections & section) {
    // The section is expanded, so the maxiview should be opaque (visible) and
    // the miniview should be hidden.
    elm.classList.remove('collapsed');
    if (maxiview) {
      maxiview.classList.remove('collapsed');
      maxiview.classList.add('opaque');
    }
    if (miniview)
      miniview.classList.remove('opaque');
  } else {
    // The section is collapsed, so the maxiview should be hidden and the
    // miniview should be opaque.
    elm.classList.add('collapsed');
    if (maxiview) {
      maxiview.classList.add('collapsed');
      maxiview.classList.remove('opaque');
    }
    if (miniview)
      miniview.classList.add('opaque');
  }
}

var sessionItems = [];

function foreignSessions(data) {
  logEvent('received foreign sessions');
  // We need to store the foreign sessions so we can update the layout on a
  // resize.
  sessionItems = data;
  renderForeignSessions();
  layoutSections();
}

function renderForeignSessions() {
  // Remove all existing items and create new items.
  var sessionElement = $('foreign-sessions');
  var parentSessionElement = sessionElement.lastElementChild;
  parentSessionElement.textContent = '';

  // For each client, create entries and append the lists together.
  sessionItems.forEach(function(item, i) {
    // TODO(zea): Get real client names. See crbug/59672.
    var name = 'Client ' + i;
    parentSessionElement.appendChild(createForeignSession(item, name));
  });

  layoutForeignSessions();
}

function layoutForeignSessions() {
  var sessionElement = $('foreign-sessions');
  // We cannot use clientWidth here since the width has a transition.
  var availWidth = useSmallGrid() ? 692 : 920;
  var parentSessEl = sessionElement.lastElementChild;

  if (parentSessEl.hasChildNodes()) {
    sessionElement.classList.remove('disabled');
    sessionElement.classList.remove('opaque');
  } else {
    sessionElement.classList.add('disabled');
    sessionElement.classList.add('opaque');
  }
}

function createForeignSession(client, name) {
  // Vertically stack the windows in a client.
  var stack = document.createElement('div');
  stack.className = 'foreign-session-client item link';
  stack.textContent = name;
  stack.sessionTag = client[0].sessionTag;

  client.forEach(function(win, i) {
    // Create a window entry.
    var winSpan = document.createElement('span');
    var winEl = document.createElement('p');
    winEl.className = 'item link window';
    winEl.tabItems = win.tabs;
    winEl.tabIndex = 0;
    winEl.textContent = formatTabsText(win.tabs.length);
    winEl.xtitle = win.title;
    winEl.sessionTag = win.sessionTag;
    winEl.winNum = i;
    winEl.addEventListener('click', maybeOpenForeignWindow);
    winEl.addEventListener('keydown',
                           handleIfEnterKey(maybeOpenForeignWindow));
    winSpan.appendChild(winEl);

    // Sort tabs by MRU order
    win.tabs.sort(function(a, b) {
      return a.timestamp < b.timestamp;
    });

    // Create individual tab information.
    win.tabs.forEach(function(data) {
        var tabEl = document.createElement('a');
        tabEl.className = 'item link tab';
        tabEl.href = data.timestamp;
        tabEl.style.backgroundImage = url('chrome://favicon/' + data.url);
        tabEl.dir = data.direction;
        tabEl.textContent = data.title;
        tabEl.sessionTag = win.sessionTag;
        tabEl.winNum = i;
        tabEl.sessionId = data.sessionId;
        tabEl.addEventListener('click', maybeOpenForeignTab);
        tabEl.addEventListener('keydown',
                               handleIfEnterKey(maybeOpenForeignTab));

        winSpan.appendChild(tabEl);
    });

    // Append the window.
    stack.appendChild(winSpan);
  });
  return stack;
}

var recentItems = [];

function recentlyClosedTabs(data) {
  logEvent('received recently closed tabs');
  // We need to store the recent items so we can update the layout on a resize.
  recentItems = data;
  renderRecentlyClosed();
  layoutSections();
}

function renderRecentlyClosed() {
  // Remove all existing items and create new items.
  var recentElement = $('recently-closed');
  var parentEl = recentElement.lastElementChild;
  parentEl.textContent = '';
  var recentMenu = $('recently-closed-menu');
  clearClosedMenu(recentMenu);

  recentItems.forEach(function(item) {
    parentEl.appendChild(createRecentItem(item));
    addRecentMenuItem(recentMenu, item);
  });
  addClosedMenuFooter(recentMenu, 'recently-closed', MENU_RECENT);

  layoutRecentlyClosed();
}

function createRecentItem(data) {
  var isWindow = data.type == 'window';
  var el;
  if (isWindow) {
    el = document.createElement('span');
    el.className = 'item link window';
    el.tabItems = data.tabs;
    el.tabIndex = 0;
    el.textContent = formatTabsText(data.tabs.length);
  } else {
    el = document.createElement('a');
    el.className = 'item';
    el.href = data.url;
    el.ping = getAppPingUrl(
        'PING_BY_URL', data.url, 'NTP_RECENTLY_CLOSED');
    el.style.backgroundImage = url('chrome://favicon/' + data.url);
    el.dir = data.direction;
    el.textContent = data.title;
  }
  el.sessionId = data.sessionId;
  el.xtitle = data.title;
  el.sessionTag = data.sessionTag;
  var wrapperEl = document.createElement('span');
  wrapperEl.appendChild(el);
  return wrapperEl;
}

function addRecentMenuItem(menu, data) {
  var isWindow = data.type == 'window';
  var a = document.createElement('a');
  if (isWindow) {
    a.textContent = formatTabsText(data.tabs.length);
    a.className = 'window';  // To get the icon from the CSS .window rule.
    a.href = '';  // To make underline show up.
  } else {
    a.href = data.url;
    a.ping = getAppPingUrl(
        'PING_BY_URL', data.url, 'NTP_RECENTLY_CLOSED');
    a.style.backgroundImage = 'url(chrome://favicon/' + data.url + ')';
    a.textContent = data.title;
  }
  function clickHandler(e) {
    chrome.send('reopenTab', [String(data.sessionId)]);
    e.preventDefault();
  }
  a.addEventListener('click', clickHandler);
  addClosedMenuEntryWithLink(menu, a);
}

function saveShownSections() {
  chrome.send('setShownSections', [shownSections]);
}

var LayoutMode = {
  SMALL: 1,
  NORMAL: 2
};

var layoutMode = useSmallGrid() ? LayoutMode.SMALL : LayoutMode.NORMAL;

function handleWindowResize() {
  if (window.innerWidth < 10) {
    // We're probably a background tab, so don't do anything.
    return;
  }

  // TODO(jstritar): Remove the small-layout class and revert back to the
  // @media (max-width) directive once http://crbug.com/70930 is fixed.
  var oldLayoutMode = layoutMode;
  var b = useSmallGrid();
  if (b) {
    layoutMode = LayoutMode.SMALL;
    document.body.classList.add('small-layout');
  } else {
    layoutMode = LayoutMode.NORMAL;
    document.body.classList.remove('small-layout');
  }

  if (layoutMode != oldLayoutMode){
    mostVisited.useSmallGrid = b;
    mostVisited.layout();
    apps.layout({force:true});
    renderRecentlyClosed();
    renderForeignSessions();
    updateAllMiniviewClippings();
  }

  layoutSections();
}

// Stores some information about each section necessary to layout. A new
// instance is constructed for each section on each layout.
function SectionLayoutInfo(section) {
  this.section = section;
  this.header = section.querySelector('h2');
  this.miniview = section.querySelector('.miniview');
  this.maxiview = getSectionMaxiview(section);
  this.expanded = this.maxiview && !section.classList.contains('collapsed');
  this.fixedHeight = this.section.offsetHeight;
  this.scrollingHeight = 0;

  if (this.expanded)
    this.scrollingHeight = this.maxiview.offsetHeight;
}

// Get all sections to be layed out.
SectionLayoutInfo.getAll = function() {
  var sections = document.querySelectorAll(
      '.section:not(.disabled):not(.menu)');
  var result = [];
  for (var i = 0, section; section = sections[i]; i++) {
    result.push(new SectionLayoutInfo(section));
  }
  return result;
};

// Ensure the miniview sections don't have any clipped items.
function updateMiniviewClipping(miniview) {
  var clipped = false;
  for (var j = 0, item; item = miniview.children[j]; j++) {
    item.style.display = '';
    if (clipped ||
        (item.offsetLeft + item.offsetWidth) > miniview.offsetWidth) {
      item.style.display = 'none';
      clipped = true;
    } else {
      item.style.display = '';
    }
  }
}

// Ensure none of the miniviews have any clipped items.
function updateAllMiniviewClippings() {
  var miniviews = document.querySelectorAll('.section.collapsed .miniview');
  for (var i = 0, miniview; miniview = miniviews[i]; i++) {
    updateMiniviewClipping(miniview);
  }
}

// Returns whether or not vertical scrollbars are present.
function hasScrollBars() {
  return window.innerHeight != document.body.clientHeight;
}

// Enables scrollbars (they will only show up if needed).
function showScrollBars() {
  document.body.classList.remove('noscroll');
}

// Hides all scrollbars.
function hideScrollBars() {
  document.body.classList.add('noscroll');
}

// Returns whether or not the sections are currently animating due to a
// section transition.
function isAnimating() {
  var de = document.documentElement;
  return de.getAttribute('enable-section-animations') == 'true';
}

// Layout the sections in a modified accordian. The header and miniview, if
// visible are fixed within the viewport. If there is an expanded section, its
// it scrolls.
//
// =============================
// | collapsed section         |  <- Any collapsed sections are fixed position.
// | and miniview              |
// |---------------------------|
// | expanded section          |
// |                           |  <- There can be one expanded section and it
// | and maxiview              |     is absolutely positioned so that it can
// |                           |     scroll "underneath" the fixed elements.
// |                           |
// |---------------------------|
// | another collapsed section |
// |---------------------------|
//
// We want the main frame scrollbar to be the one that scrolls the expanded
// region. To get this effect, we make the fixed elements position:fixed and the
// scrollable element position:absolute. We also artificially increase the
// height of the document so that it is possible to scroll down enough to
// display the end of the document, even with any fixed elements at the bottom
// of the viewport.
//
// There is a final twist: If the intrinsic height of the expanded section is
// less than the available height (because the window is tall), any collapsed
// sections sinch up and sit below the expanded section. This is so that we
// don't have a bunch of dead whitespace in the case of expanded sections that
// aren't very tall.
function layoutSections() {
  // While transitioning sections, we only want scrollbars to appear if they're
  // already present or the window is being resized (so there's no animation).
  if (!hasScrollBars() && isAnimating())
    hideScrollBars();

  var sections = SectionLayoutInfo.getAll();
  var expandedSection = null;
  var headerHeight = LAYOUT_SPACING_TOP;
  var footerHeight = 0;

  // Calculate the height of the fixed elements above the expanded section. Also
  // take note of the expanded section, if there is one.
  var i;
  var section;
  for (i = 0; section = sections[i]; i++) {
    headerHeight += section.fixedHeight;
    if (section.expanded) {
      expandedSection = section;
      i++;
      break;
    }
  }

  // Calculate the height of the fixed elements below the expanded section, if
  // any.
  for (; section = sections[i]; i++) {
    footerHeight += section.fixedHeight;
  }
  // Leave room for bottom bar if it's visible.
  footerHeight += $('closed-sections-bar').offsetHeight;


  // Determine the height to use for the expanded section. If there isn't enough
  // space to show the expanded section completely, this will be the available
  // height. Otherwise, we use the intrinsic height of the expanded section.
  var expandedSectionHeight;
  if (expandedSection) {
    var flexHeight = window.innerHeight - headerHeight - footerHeight;
    if (flexHeight < expandedSection.scrollingHeight) {
      expandedSectionHeight = flexHeight;

      // Also, artificially expand the height of the document so that we can see
      // the entire expanded section.
      //
      // TODO(aa): Where does this come from? It is the difference between what
      // we set document.body.style.height to and what
      // document.body.scrollHeight measures afterward. I expect them to be the
      // same if document.body has no margins.
      var fudge = 44;
      document.body.style.height =
          headerHeight +
          expandedSection.scrollingHeight +
          footerHeight +
          fudge +
          'px';
    } else {
      expandedSectionHeight = expandedSection.scrollingHeight;
      document.body.style.height = '';
    }
  } else {
    // We only set the document height when a section is expanded. If
    // all sections are collapsed, then get rid of the previous height.
    document.body.style.height = '';
  }

  maxiviewVisibleHeight = expandedSectionHeight;

  // Now position all the elements.
  var y = LAYOUT_SPACING_TOP;
  for (i = 0, section; section = sections[i]; i++) {
    section.section.style.top = y + 'px';
    y += section.fixedHeight;

    if (section.maxiview) {
      if (section == expandedSection) {
        section.maxiview.style.top = y + 'px';
      } else {
        // The miniviews fade out gradually, so it may have height at this
        // point. We position the maxiview as if the miniview was not displayed
        // by subtracting off the miniview's total height (height + margin).
        var miniviewFudge = 40;  // miniview margin-bottom + margin-top
        var miniviewHeight = section.miniview.offsetHeight + miniviewFudge;
        section.maxiview.style.top = y - miniviewHeight + 'px';
      }
    }

    if (section.maxiview && section == expandedSection)
      updateMask(section.maxiview, expandedSectionHeight);

    if (section == expandedSection)
      y += expandedSectionHeight;
  }
  if (cr.isChromeOS)
    $('closed-sections-bar').style.top = y + 'px';

  updateMenuSections();
  updateAttributionDisplay(y);
}

function updateMask(maxiview, visibleHeightPx) {
  // We want to end up with 10px gradients at the top and bottom of
  // visibleHeight, but webkit-mask only supports expression in terms of
  // percentages.

  // We might not have enough room to do 10px gradients on each side. To get the
  // right effect, we don't want to make the gradients smaller, but make them
  // appear to mush into each other.
  var gradientHeightPx = Math.min(10, Math.floor(visibleHeightPx / 2));
  var gradientDestination = 'rgba(0,0,0,' + (gradientHeightPx / 10) + ')';

  var bottomSpacing = 15;
  var first = parseFloat(maxiview.style.top) / window.innerHeight;
  var second = first + gradientHeightPx / window.innerHeight;
  var fourth = first + (visibleHeightPx - bottomSpacing) / window.innerHeight;
  var third = fourth - gradientHeightPx / window.innerHeight;

  var gradientArguments = [
    'transparent',
    getColorStopString(first, 'transparent'),
    getColorStopString(second, gradientDestination),
    getColorStopString(third, gradientDestination),
    getColorStopString(fourth, 'transparent'),
    'transparent'
  ];

  var gradient = '-webkit-linear-gradient(' + gradientArguments.join(',') + ')';
  maxiview.style.WebkitMaskImage = gradient;
}

function getColorStopString(height, color) {
  // TODO(arv): The CSS3 gradient syntax allows px units so we should simplify
  // this to use pixels instead.
  return color + ' ' + height * 100 + '%';
}

// Updates the visibility of the menu buttons for each section, based on
// whether they are currently enabled and in menu mode.
function updateMenuSections() {
  var elms = document.getElementsByClassName('section');
  for (var i = 0, elm; elm = elms[i]; i++) {
    var button = getSectionMenuButton(elm.id);
    if (!button)
      continue;

    if (!elm.classList.contains('disabled') &&
        elm.classList.contains('menu')) {
      button.style.display = 'inline-block';
    } else {
      button.style.display = 'none';
    }
  }
}

window.addEventListener('resize', handleWindowResize);

var sectionToElementMap;
function getSectionElement(section) {
  if (!sectionToElementMap) {
    sectionToElementMap = {};
    for (var key in Section) {
      sectionToElementMap[Section[key]] =
          document.querySelector('.section[section=' + key + ']');
    }
  }
  return sectionToElementMap[section];
}

function getSectionMaxiview(section) {
  return $(section.id + '-maxiview');
}

function getSectionMiniview(section) {
  return section.querySelector('.miniview');
}

// You usually want to call |showOnlySection()| instead of this.
function showSection(section) {
  if (!(section & shownSections)) {
    shownSections |= section;
    var el = getSectionElement(section);
    if (el) {
      el.classList.remove('collapsed');

      var maxiview = getSectionMaxiview(el);
      if (maxiview) {
        maxiview.classList.remove('collapsing');
        maxiview.classList.remove('collapsed');
        // The opacity won't transition if you toggle the display property
        // at the same time. To get a fade effect, we set the opacity
        // asynchronously from another function, after the display is toggled.
        //   1) 'collapsed' (display: none, opacity: 0)
        //   2) none (display: block, opacity: 0)
        //   3) 'opaque' (display: block, opacity: 1)
        setTimeout(function () {
          maxiview.classList.add('opaque');
        }, 0);
      }

      var miniview = getSectionMiniview(el);
      if (miniview) {
        // The miniview is hidden immediately (no need to set this async).
        miniview.classList.remove('opaque');
      }
    }

    switch (section) {
      case Section.THUMB:
        mostVisited.visible = true;
        mostVisited.layout();
        break;
      case Section.APPS:
        apps.visible = true;
        apps.layout({disableAnimations:true});
        break;
    }
  }
}

// Show this section and hide all other sections - at most one section can
// be open at one time.
function showOnlySection(section) {
  for (var p in Section) {
    if (p == section)
      showSection(Section[p]);
    else
      hideSection(Section[p]);
  }
}

function hideSection(section) {
  if (section & shownSections) {
    shownSections &= ~section;

    switch (section) {
      case Section.THUMB:
        mostVisited.visible = false;
        mostVisited.layout();
        break;
      case Section.APPS:
        apps.visible = false;
        apps.layout();
        break;
    }

    var el = getSectionElement(section);
    if (el) {
      el.classList.add('collapsed');

      var maxiview = getSectionMaxiview(el);
      if (maxiview) {
        maxiview.classList.add(isDoneLoading() ? 'collapsing' : 'collapsed');
        maxiview.classList.remove('opaque');
      }

      var miniview = getSectionMiniview(el);
      if (miniview) {
        // We need to set this asynchronously to properly get the fade effect.
        setTimeout(function() {
          miniview.classList.add('opaque');
        }, 0);
        updateMiniviewClipping(miniview);
      }
    }
  }
}

window.addEventListener('webkitTransitionEnd', function(e) {
  if (e.target.classList.contains('collapsing')) {
    e.target.classList.add('collapsed');
    e.target.classList.remove('collapsing');
  }

  if (e.target.classList.contains('maxiview') ||
      e.target.classList.contains('miniview'))  {
    document.documentElement.removeAttribute('enable-section-animations');
    showScrollBars();
  }
});

/**
 * Callback when the shown sections changes in another NTP.
 * @param {number} newShownSections Bitmask of the shown sections.
 */
function setShownSections(newShownSections) {
  for (var key in Section) {
    if (newShownSections & Section[key])
      showSection(Section[key]);
    else
      hideSection(Section[key]);
  }
  setSectionMenuMode('apps', Section.APPS, newShownSections & MENU_APPS,
                     MENU_APPS);
  setSectionMenuMode('most-visited', Section.THUMB,
                     newShownSections & MENU_THUMB, MENU_THUMB);
  setSectionMenuMode('recently-closed', undefined,
                     newShownSections & MENU_RECENT, MENU_RECENT);
  layoutSections();
}

// Recently closed

function layoutRecentlyClosed() {
  var recentElement = $('recently-closed');
  var miniview = getSectionMiniview(recentElement);

  updateMiniviewClipping(miniview);

  if (miniview.hasChildNodes()) {
    recentElement.classList.remove('disabled');
    miniview.classList.add('opaque');
  } else {
    recentElement.classList.add('disabled');
    miniview.classList.remove('opaque');
  }

  layoutSections();
}

/**
 * This function is called by the backend whenever the sync status section
 * needs to be updated to reflect recent sync state changes. The backend passes
 * the new status information in the newMessage parameter. The state includes
 * the following:
 *
 * syncsectionisvisible: true if the sync section needs to show up on the new
 *                       tab page and false otherwise.
 * title: the header for the sync status section.
 * msg: the actual message (e.g. "Synced to foo@gmail.com").
 * linkisvisible: true if the link element should be visible within the sync
 *                section and false otherwise.
 * linktext: the text to display as the link in the sync status (only used if
 *           linkisvisible is true).
 * linkurlisset: true if an URL should be set as the href for the link and false
 *               otherwise. If this field is false, then clicking on the link
 *               will result in sending a message to the backend (see
 *               'SyncLinkClicked').
 * linkurl: the URL to use as the element's href (only used if linkurlisset is
 *          true).
 */
function syncMessageChanged(newMessage) {
  var syncStatusElement = $('sync-status');

  // Hide the section if the message is emtpy.
  if (!newMessage['syncsectionisvisible']) {
    syncStatusElement.classList.add('disabled');
    return;
  }

  syncStatusElement.classList.remove('disabled');

  var content = syncStatusElement.children[0];

  // Set the sync section background color based on the state.
  if (newMessage.msgtype == 'error') {
    content.style.backgroundColor = 'tomato';
  } else {
    content.style.backgroundColor = '';
  }

  // Set the text for the header and sync message.
  var titleElement = content.firstElementChild;
  titleElement.textContent = newMessage.title;
  var messageElement = titleElement.nextElementSibling;
  messageElement.textContent = newMessage.msg;

  // Remove what comes after the message
  while (messageElement.nextSibling) {
    content.removeChild(messageElement.nextSibling);
  }

  if (newMessage.linkisvisible) {
    var el;
    if (newMessage.linkurlisset) {
      // Use a link
      el = document.createElement('a');
      el.href = newMessage.linkurl;
    } else {
      el = document.createElement('button');
      el.className = 'link';
      el.addEventListener('click', syncSectionLinkClicked);
    }
    el.textContent = newMessage.linktext;
    content.appendChild(el);
    fixLinkUnderline(el);
  }

  layoutSections();
}

/**
 * Invoked when the link in the sync promo or sync status section is clicked.
 */
function syncSectionLinkClicked(e) {
  chrome.send('SyncLinkClicked');
  e.preventDefault();
}

/**
 * Invoked when link to start sync in the promo message is clicked, and Chrome
 * has already been synced to an account.
 */
function syncAlreadyEnabled(message) {
  showNotification(message.syncEnabledMessage);
}

/**
 * Returns the text used for a recently closed window.
 * @param {number} numTabs Number of tabs in the window.
 * @return {string} The text to use.
 */
function formatTabsText(numTabs) {
  if (numTabs == 1)
    return localStrings.getString('closedwindowsingle');
  return localStrings.getStringF('closedwindowmultiple', numTabs);
}

// Theme related

function themeChanged(hasAttribution) {
  document.documentElement.setAttribute('hasattribution', hasAttribution);
  $('themecss').href = 'chrome://theme/css/newtab.css?' + Date.now();
  updateAttribution();
}

function updateAttribution() {
  // Default value for standard NTP with no theme attribution or custom logo.
  logEvent('updateAttribution called');
  var imageId = 'IDR_PRODUCT_LOGO';
  // Theme attribution always overrides custom logos.
  if (document.documentElement.getAttribute('hasattribution') == 'true') {
    logEvent('updateAttribution called with THEME ATTR');
    imageId = 'IDR_THEME_NTP_ATTRIBUTION';
  } else if (document.documentElement.getAttribute('customlogo') == 'true') {
    logEvent('updateAttribution with CUSTOMLOGO');
    imageId = 'IDR_CUSTOM_PRODUCT_LOGO';
  }

  $('attribution-img').src = 'chrome://theme/' + imageId + '?' + Date.now();
}

// If the content overlaps with the attribution, we bump its opacity down.
function updateAttributionDisplay(contentBottom) {
  var attribution = $('attribution');
  var main = $('main');
  var rtl = document.documentElement.dir == 'rtl';
  var contentRect = main.getBoundingClientRect();
  var attributionRect = attribution.getBoundingClientRect();

  // Hack. See comments for '.haslayout' in new_tab.css.
  if (attributionRect.width == 0)
    return;
  else
    attribution.classList.remove('nolayout');

  if (contentBottom > attribution.offsetTop) {
    if ((!rtl && contentRect.right > attributionRect.left) ||
        (rtl && attributionRect.right > contentRect.left)) {
      attribution.classList.add('obscured');
      return;
    }
  }

  attribution.classList.remove('obscured');
}

function bookmarkBarAttached() {
  document.documentElement.setAttribute('bookmarkbarattached', 'true');
}

function bookmarkBarDetached() {
  document.documentElement.setAttribute('bookmarkbarattached', 'false');
}

function viewLog() {
  var lines = [];
  var start = log[0][1];

  for (var i = 0; i < log.length; i++) {
    lines.push((log[i][1] - start) + ': ' + log[i][0]);
  }

  console.log(lines.join('\n'));
}

// We apply the size class here so that we don't trigger layout animations
// onload.

handleWindowResize();

var localStrings = new LocalStrings();

///////////////////////////////////////////////////////////////////////////////
// Things we know are not needed at startup go below here

function afterTransition(f) {
  if (!isDoneLoading()) {
    // Make sure we do not use a timer during load since it slows down the UI.
    f();
  } else {
    // The duration of all transitions are .15s
    window.setTimeout(f, 150);
  }
}

// Notification


var notificationTimeout;

/*
 * Displays a message (either a string or a document fragment) in the
 * notification slot at the top of the NTP. A close button ("x") will be
 * inserted at the end of the message.
 * @param {string|Node} message String or node to use as message.
 * @param {string} actionText The text to show as a link next to the message.
 * @param {function=} opt_f Function to call when the user clicks the action
 *                          link.
 * @param {number=} opt_delay The time in milliseconds before hiding the
 *                            notification.
 */
function showNotification(message, actionText, opt_f, opt_delay) {
// TODO(arv): Create a notification component.
  var notificationElement = $('notification');
  var f = opt_f || function() {};
  var delay = opt_delay || 10000;

  function show() {
    window.clearTimeout(notificationTimeout);
    notificationElement.classList.add('show');
    document.body.classList.add('notification-shown');
  }

  function delayedHide() {
    notificationTimeout = window.setTimeout(hideNotification, delay);
  }

  function doAction() {
    f();
    closeNotification();
  }

  function closeNotification() {
    if (notification.classList.contains('promo'))
      chrome.send('closePromo');
    hideNotification();
  }

  // Remove classList entries from previous notifications.
  notification.classList.remove('first-run');
  notification.classList.remove('promo');

  var messageContainer = notificationElement.firstElementChild;
  var actionLink = notificationElement.querySelector('#action-link');
  var closeButton = notificationElement.querySelector('#notification-close');

  // Remove any previous actionLink entry.
  actionLink.textContent = '';

  $('notification-close').onclick = closeNotification;

  if (typeof message == 'string') {
    messageContainer.textContent = message;
  } else {
    messageContainer.textContent = '';  // Remove all children.
    messageContainer.appendChild(message);
  }

  if (actionText) {
    actionLink.style.display = '';
    actionLink.textContent = actionText;
  } else {
    actionLink.style.display = 'none';
  }

  actionLink.onclick = doAction;
  actionLink.onkeydown = handleIfEnterKey(doAction);
  notificationElement.onmouseover = show;
  notificationElement.onmouseout = delayedHide;
  actionLink.onfocus = show;
  actionLink.onblur = delayedHide;
  // Enable tabbing to the link now that it is shown.
  actionLink.tabIndex = 0;

  show();
  delayedHide();
}

/**
 * Hides the notifier.
 */
function hideNotification() {
  var notificationElement = $('notification');
  notificationElement.classList.remove('show');
  document.body.classList.remove('notification-shown');
  var actionLink = notificationElement.querySelector('#actionlink');
  var closeButton = notificationElement.querySelector('#notification-close');
  // Prevent tabbing to the hidden link.
  // Setting tabIndex to -1 only prevents future tabbing to it. If, however, the
  // user switches window or a tab and then moves back to this tab the element
  // may gain focus. We therefore make sure that we blur the element so that the
  // element focus is not restored when coming back to this window.
  if (actionLink) {
    actionLink.tabIndex = -1;
    actionLink.blur();
  }
  if (closeButton) {
    closeButton.tabIndex = -1;
    closeButton.blur();
  }
}

function showPromoNotification() {
  showNotification(parseHtmlSubset(localStrings.getString('serverpromo')),
                   localStrings.getString('syncpromotext'),
                   function () { chrome.send('SyncLinkClicked'); },
                   60000);
  var notificationElement = $('notification');
  notification.classList.add('promo');
}

$('main').addEventListener('click', function(e) {
  var p = e.target;
  while (p && p.tagName != 'H2') {
    // In case the user clicks on a button we do not want to expand/collapse a
    // section.
    if (p.tagName == 'BUTTON')
      return;
    p = p.parentNode;
  }

  if (!p)
    return;

  p = p.parentNode;
  if (!getSectionMaxiview(p))
    return;

  toggleSectionVisibilityAndAnimate(p.getAttribute('section'));
});

$('most-visited-settings').addEventListener('click', function() {
  $('clear-all-blacklisted').execute();
});

function toggleSectionVisibilityAndAnimate(section) {
  if (!section)
    return;

  // It looks better to return the scroll to the top when toggling sections.
  document.body.scrollTop = 0;

  // We set it back in webkitTransitionEnd.
  document.documentElement.setAttribute('enable-section-animations', 'true');
  if (shownSections & Section[section]) {
    hideSection(Section[section]);
  } else {
    showOnlySection(section);
  }
  layoutSections();
  saveShownSections();
}

function handleIfEnterKey(f) {
  return function(e) {
    if (e.keyIdentifier == 'Enter')
      f(e);
  };
}

function maybeReopenTab(e) {
  var el = findAncestor(e.target, function(el) {
    return el.sessionId !== undefined;
  });
  if (el) {
    chrome.send('reopenTab', [String(el.sessionId)]);
    e.preventDefault();

    setWindowTooltipTimeout();
  }
}

// Note that the openForeignSession calls can fail, resulting this method to
// not have any action (hence the maybe).
function maybeOpenForeignSession(e) {
  var el = findAncestor(e.target, function(el) {
    return el.sessionTag !== undefined;
  });
  if (el) {
    chrome.send('openForeignSession', [String(el.sessionTag)]);
    e.stopPropagation();
    e.preventDefault();
    setWindowTooltipTimeout();
  }
}

function maybeOpenForeignWindow(e) {
  var el = findAncestor(e.target, function(el) {
    return el.winNum !== undefined;
  });
  if (el) {
    chrome.send('openForeignSession', [String(el.sessionTag),
        String(el.winNum)]);
    e.stopPropagation();
    e.preventDefault();
    setWindowTooltipTimeout();
  }
}

function maybeOpenForeignTab(e) {
  var el = findAncestor(e.target, function(el) {
    return el.sessionId !== undefined;
  });
  if (el) {
    chrome.send('openForeignSession', [String(el.sessionTag), String(el.winNum),
        String(el.sessionId)]);
    e.stopPropagation();
    e.preventDefault();
    setWindowTooltipTimeout();
  }
}

// HACK(arv): After the window onblur event happens we get a mouseover event
// on the next item and we want to make sure that we do not show a tooltip
// for that.
function setWindowTooltipTimeout(e) {
  window.setTimeout(function() {
    windowTooltip.hide();
  }, 2 * WindowTooltip.DELAY);
}

function maybeShowWindowTooltip(e) {
  var f = function(el) {
    return el.tabItems !== undefined;
  };
  var el = findAncestor(e.target, f);
  var relatedEl = findAncestor(e.relatedTarget, f);
  if (el && el != relatedEl) {
    windowTooltip.handleMouseOver(e, el, el.tabItems);
  }
}


var recentlyClosedElement = $('recently-closed');

recentlyClosedElement.addEventListener('click', maybeReopenTab);
recentlyClosedElement.addEventListener('keydown',
                                       handleIfEnterKey(maybeReopenTab));

recentlyClosedElement.addEventListener('mouseover', maybeShowWindowTooltip);
recentlyClosedElement.addEventListener('focus', maybeShowWindowTooltip, true);

var foreignSessionElement = $('foreign-sessions');

foreignSessionElement.addEventListener('click', maybeOpenForeignSession);
foreignSessionElement.addEventListener('keydown',
                                       handleIfEnterKey(
                                           maybeOpenForeignSession));

foreignSessionElement.addEventListener('mouseover', maybeShowWindowTooltip);
foreignSessionElement.addEventListener('focus', maybeShowWindowTooltip, true);

/**
 * This object represents a tooltip representing a closed window. It is
 * shown when hovering over a closed window item or when the item is focused. It
 * gets hidden when blurred or when mousing out of the menu or the item.
 * @param {Element} tooltipEl The element to use as the tooltip.
 * @constructor
 */
function WindowTooltip(tooltipEl) {
  this.tooltipEl = tooltipEl;
  this.boundHide_ = this.hide.bind(this);
  this.boundHandleMouseOut_ = this.handleMouseOut.bind(this);
}

WindowTooltip.trackMouseMove_ = function(e) {
  WindowTooltip.clientX = e.clientX;
  WindowTooltip.clientY = e.clientY;
};

/**
 * Time in ms to delay before the tooltip is shown.
 * @type {number}
 */
WindowTooltip.DELAY = 300;

WindowTooltip.prototype = {
  timer: 0,
  handleMouseOver: function(e, linkEl, tabs) {
    this.linkEl_ = linkEl;
    if (e.type == 'mouseover') {
      this.linkEl_.addEventListener('mousemove', WindowTooltip.trackMouseMove_);
      this.linkEl_.addEventListener('mouseout', this.boundHandleMouseOut_);
    } else { // focus
      this.linkEl_.addEventListener('blur', this.boundHide_);
    }
    this.timer = window.setTimeout(this.show.bind(this, e.type, linkEl, tabs),
                                   WindowTooltip.DELAY);
  },
  show: function(type, linkEl, tabs) {
    window.addEventListener('blur', this.boundHide_);
    this.linkEl_.removeEventListener('mousemove',
                                     WindowTooltip.trackMouseMove_);
    window.clearTimeout(this.timer);

    this.renderItems(tabs);
    var rect = linkEl.getBoundingClientRect();
    var bodyRect = document.body.getBoundingClientRect();
    var rtl = document.documentElement.dir == 'rtl';

    this.tooltipEl.style.display = 'block';
    var tooltipRect = this.tooltipEl.getBoundingClientRect();
    var x, y;

    // When focused show below, like a drop down menu.
    if (type == 'focus') {
      x = rtl ?
          rect.left + bodyRect.left + rect.width - this.tooltipEl.offsetWidth :
          rect.left + bodyRect.left;
      y = rect.top + bodyRect.top + rect.height;
    } else {
      x = bodyRect.left + (rtl ?
          WindowTooltip.clientX - this.tooltipEl.offsetWidth :
          WindowTooltip.clientX);
      // Offset like a tooltip
      y = 20 + WindowTooltip.clientY + bodyRect.top;
    }

    // We need to ensure that the tooltip is inside the window viewport.
    x = Math.min(x, bodyRect.width - tooltipRect.width);
    x = Math.max(x, 0);
    y = Math.min(y, bodyRect.height - tooltipRect.height);
    y = Math.max(y, 0);

    this.tooltipEl.style.left = x + 'px';
    this.tooltipEl.style.top = y + 'px';
  },
  handleMouseOut: function(e) {
    // Don't hide when move to another item in the link.
    var f = function(el) {
      return el.tabItems !== undefined;
    };
    var el = findAncestor(e.target, f);
    var relatedEl = findAncestor(e.relatedTarget, f);
    if (el && el != relatedEl) {
      this.hide();
    }
  },
  hide: function() {
    window.clearTimeout(this.timer);
    window.removeEventListener('blur', this.boundHide_);
    this.linkEl_.removeEventListener('mousemove',
                                     WindowTooltip.trackMouseMove_);
    this.linkEl_.removeEventListener('mouseout', this.boundHandleMouseOut_);
    this.linkEl_.removeEventListener('blur', this.boundHide_);
    this.linkEl_ = null;

    this.tooltipEl.style.display  = 'none';
  },
  renderItems: function(tabs) {
    var tooltip = this.tooltipEl;
    tooltip.textContent = '';

    tabs.forEach(function(tab) {
      var span = document.createElement('span');
      span.className = 'item';
      span.style.backgroundImage = url('chrome://favicon/' + tab.url);
      span.dir = tab.direction;
      span.textContent = tab.title;
      tooltip.appendChild(span);
    });
  }
};

var windowTooltip = new WindowTooltip($('window-tooltip'));

window.addEventListener('load',
                        logEvent.bind(global, 'Tab.NewTabOnload', true));

window.addEventListener('resize', handleWindowResize);
document.addEventListener('DOMContentLoaded',
    logEvent.bind(global, 'Tab.NewTabDOMContentLoaded', true));

// Whether or not we should send the initial 'GetSyncMessage' to the backend
// depends on the value of the attribue 'syncispresent' which the backend sets
// to indicate if there is code in the backend which is capable of processing
// this message. This attribute is loaded by the JSTemplate and therefore we
// must make sure we check the attribute after the DOM is loaded.
document.addEventListener('DOMContentLoaded',
                          callGetSyncMessageIfSyncIsPresent);

/**
 * The sync code is not yet built by default on all platforms so we have to
 * make sure we don't send the initial sync message to the backend unless the
 * backend told us that the sync code is present.
 */
function callGetSyncMessageIfSyncIsPresent() {
  if (document.documentElement.getAttribute('syncispresent') == 'true') {
    chrome.send('GetSyncMessage');
  }
}

// Tooltip for elements that have text that overflows.
document.addEventListener('mouseover', function(e) {
  // We don't want to do this while we are dragging because it makes things very
  // janky
  if (mostVisited.isDragging()) {
    return;
  }

  var el = findAncestor(e.target, function(el) {
    return el.xtitle;
  });
  if (el && el.xtitle != el.title) {
    if (el.scrollWidth > el.clientWidth) {
      el.title = el.xtitle;
    } else {
      el.title = '';
    }
  }
});

/**
 * Makes links and buttons support a different underline color.
 * @param {Node} node The node to search for links and buttons in.
 */
function fixLinkUnderlines(node) {
  var elements = node.querySelectorAll('a,button');
  Array.prototype.forEach.call(elements, fixLinkUnderline);
}

/**
 * Wraps the content of an element in a a link-color span.
 * @param {Element} el The element to wrap.
 */
function fixLinkUnderline(el) {
  var span = document.createElement('span');
  span.className = 'link-color';
  while (el.hasChildNodes()) {
    span.appendChild(el.firstChild);
  }
  el.appendChild(span);
}

updateAttribution();

function initializeLogin() {
  chrome.send('initializeLogin', []);
}

function updateLogin(login) {
  $('login-container').style.display = login ? 'block' : '';
  if (login)
    $('login-username').textContent = login;

}

var mostVisited = new MostVisited(
    $('most-visited-maxiview'),
    document.querySelector('#most-visited .miniview'),
    $('most-visited-menu'),
    useSmallGrid(),
    shownSections & Section.THUMB);

function setMostVisitedPages(data, firstRun, hasBlacklistedUrls) {
  logEvent('received most visited pages');

  mostVisited.updateSettingsLink(hasBlacklistedUrls);
  mostVisited.data = data;
  mostVisited.layout();
  layoutSections();

  // Remove class name in a timeout so that changes done in this JS thread are
  // not animated.
  window.setTimeout(function() {
    mostVisited.ensureSmallGridCorrect();
    maybeDoneLoading();
  }, 1);

  if (localStrings.getString('serverpromo')) {
    showPromoNotification();
  }
}

function maybeDoneLoading() {
  if (mostVisited.data && apps.loaded)
    document.body.classList.remove('loading');
}

function isDoneLoading() {
  return !document.body.classList.contains('loading');
}

// Initialize the listener for the "hide this" link on the apps promo. We do
// this outside of getAppsCallback because it only needs to be done once per
// NTP load.
document.addEventListener('DOMContentLoaded', function() {
  $('apps-promo-hide').addEventListener('click', function() {
    chrome.send('hideAppsPromo', []);
    document.documentElement.classList.remove('apps-promo-visible');
    layoutSections();
  });
});
</script>
<script>// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var MAX_APPS_PER_ROW = [];
MAX_APPS_PER_ROW[LayoutMode.SMALL] = 4;
MAX_APPS_PER_ROW[LayoutMode.NORMAL] = 6;

function getAppsCallback(data) {
  logEvent('received apps');

  // In the case of prefchange-triggered updates, we don't receive this flag.
  // Just leave it set as it was before in that case.
  if ('showPromo' in data)
    apps.showPromo = data.showPromo;

  var appsSection = $('apps');
  var appsSectionContent = $('apps-content');
  var appsMiniview = appsSection.getElementsByClassName('miniview')[0];
  var appsPromo = $('apps-promo');
  var appsPromoLink = $('apps-promo-link');
  var appsPromoPing = APP_LAUNCH_URL.PING_WEBSTORE + '+' + apps.showPromo;
  var webStoreEntry, webStoreMiniEntry;

  // Hide menu options that are not supported on the OS or windowing system.

  // The "Launch as Window" menu option.
  $('apps-launch-type-window-menu-item').hidden = data.disableAppWindowLaunch;

  // The "Create App Shortcut" menu option.
  $('apps-create-shortcut-command-menu-item').hidden =
      $('apps-create-shortcut-command-separator').hidden =
          data.disableCreateAppShortcut;

  // Hide the context menu, if there is any open.
  cr.ui.contextMenuHandler.hideMenu();

  appsMiniview.textContent = '';
  appsSectionContent.textContent = '';

  data.apps.sort(function(a,b) {
    return a.app_launch_index - b.app_launch_index;
  });

  // Determines if the web store link should be detached and place in the
  // top right of the screen.
  apps.detachWebstoreEntry =
      !apps.showPromo && data.apps.length >= MAX_APPS_PER_ROW[layoutMode];

  markNewApps(data.apps);
  apps.data = data.apps;

  clearClosedMenu(apps.menu);

  // We wait for the app icons to load before displaying them, but never wait
  // longer than 200ms.
  apps.loadedImages = 0;
  apps.imageTimer = setTimeout(apps.showImages.bind(apps), 200);

  data.apps.forEach(function(app) {
    appsSectionContent.appendChild(apps.createElement(app));
  });

  if (data.showPromo) {
    // Add the promo content...
    $('apps-promo-heading').textContent = data.promoHeader;
    appsPromoLink.href = data.promoLink;
    appsPromoLink.textContent = data.promoButton;
    appsPromoLink.ping = appsPromoPing;
    $('apps-promo').style.background =
          "url('" + data.promoLogo + "') no-repeat";
    $('apps-promo-hide').textContent = data.promoExpire;

    // ... then display the promo.
    document.documentElement.classList.add('apps-promo-visible');
  } else {
    document.documentElement.classList.remove('apps-promo-visible');
  }

  // Only show the web store entry if there are apps installed or the promo
  // is not available.
  if (data.apps.length > 0 || !data.showPromo) {
    webStoreEntry = apps.createWebStoreElement();
    webStoreEntry.querySelector('a').ping = appsPromoPing;
    appsSectionContent.appendChild(webStoreEntry);
    if (apps.detachWebstoreEntry) {
      webStoreEntry.classList.add('loner');
    } else {
      webStoreEntry.classList.remove('loner');
      apps.data.push('web-store-entry');
    }
  }

  data.apps.slice(0, MAX_MINIVIEW_ITEMS).forEach(function(app) {
    appsMiniview.appendChild(apps.createMiniviewElement(app));
    addClosedMenuEntryWithLink(apps.menu, apps.createClosedMenuElement(app));
  });
  if (data.apps.length < MAX_MINIVIEW_ITEMS) {
    webStoreMiniEntry = apps.createWebStoreMiniElement();
    webStoreMiniEntry.querySelector('a').ping = appsPromoPing;
    appsMiniview.appendChild(webStoreMiniEntry);
    addClosedMenuEntryWithLink(apps.menu,
                               apps.createWebStoreClosedMenuElement());
  }

  if (!data.showLauncher)
    hideSection(Section.APPS);
  else
    appsSection.classList.remove('disabled');

  addClosedMenuFooter(apps.menu, 'apps', MENU_APPS, Section.APPS);

  apps.loaded = true;

  if (appsPromoLink)
    appsPromoLink.ping = appsPromoPing;
  maybeDoneLoading();

  // Disable the animations when the app launcher is being (re)initailized.
  apps.layout({disableAnimations:true});

  if (isDoneLoading()) {
    updateMiniviewClipping(appsMiniview);
    layoutSections();
  }
}

function markNewApps(data) {
  var oldData = apps.data;
  data.forEach(function(app) {
    if (hashParams['app-id'] == app['id']) {
      delete hashParams['app-id'];
      app.isNew = true;
    } else if (oldData &&
        !oldData.some(function(id) { return id == app.id; })) {
      app.isNew = true;
    } else {
      app.isNew = false;
    }
  });
}

function appsPrefChangeCallback(data) {
  // Currently the only pref that is watched is the launch type.
  data.apps.forEach(function(app) {
    var appLink = document.querySelector('.app a[app-id=' + app['id'] + ']');
    if (appLink)
      appLink.setAttribute('launch-type', app['launch_type']);
  });
}

// Launches the specified app using the APP_LAUNCH_NTP_APP_RE_ENABLE histogram.
// This should only be invoked from the AppLauncherHandler.
function launchAppAfterEnable(appId) {
  chrome.send('launchApp', [appId, APP_LAUNCH.NTP_APP_RE_ENABLE]);
}

var apps = (function() {

  function createElement(app) {
    var div = document.createElement('div');
    div.className = 'app';

    var a = div.appendChild(document.createElement('a'));
    a.setAttribute('app-id', app['id']);
    a.setAttribute('launch-type', app['launch_type']);
    a.draggable = false;
    a.xtitle = a.textContent = app['name'];
    a.href = app['launch_url'];

    return div;
  }

  /**
   * Launches an application.
   * @param {string} appId Application to launch.
   * @param {MouseEvent} opt_mouseEvent Mouse event from the click that
   *     triggered the launch, used to detect modifier keys that change
   *     the tab's disposition.
   */
  function launchApp(appId, opt_mouseEvent) {
    var args = [appId, getAppLaunchType()];
    if (opt_mouseEvent) {
      // Launch came from a click - add details of the click
      // Otherwise it came from a 'command' event from elsewhere in the UI.
      args.push(opt_mouseEvent.altKey, opt_mouseEvent.ctrlKey,
                opt_mouseEvent.metaKey, opt_mouseEvent.shiftKey,
                opt_mouseEvent.button);
    }
    chrome.send('launchApp', args);
  }

  function isAppSectionMaximized() {
    return getAppLaunchType() == APP_LAUNCH.NTP_APPS_MAXIMIZED &&
      !$('apps').classList.contains('disabled');
  }

  function isAppsMenu(node) {
    return node.id == 'apps-menu';
  }

  function getAppLaunchType() {
    // We determine if the apps section is maximized, collapsed or in menu mode
    // based on the class of the apps section.
    if ($('apps').classList.contains('menu'))
      return APP_LAUNCH.NTP_APPS_MENU;
    else if ($('apps').classList.contains('collapsed'))
      return APP_LAUNCH.NTP_APPS_COLLAPSED;
    else
      return APP_LAUNCH.NTP_APPS_MAXIMIZED;
  }

  /**
   * @this {!HTMLAnchorElement}
   */
  function handleClick(e) {
    var appId = e.currentTarget.getAttribute('app-id');
    if (!appDragAndDrop.isDragging())
      launchApp(appId, e);
    return false;
  }

  // Keep in sync with LaunchType in extension_prefs.h
  var LaunchType = {
    LAUNCH_PINNED: 0,
    LAUNCH_REGULAR: 1,
    LAUNCH_FULLSCREEN: 2,
    LAUNCH_WINDOW: 3
  };

  // Keep in sync with LaunchContainer in extension_constants.h
  var LaunchContainer = {
    LAUNCH_WINDOW: 0,
    LAUNCH_PANEL: 1,
    LAUNCH_TAB: 2
  };

  var currentApp;
  var promoHasBeenSeen = false;

  function addContextMenu(el, app) {
    el.addEventListener('contextmenu', cr.ui.contextMenuHandler);
    el.addEventListener('keydown', cr.ui.contextMenuHandler);
    el.addEventListener('keyup', cr.ui.contextMenuHandler);

    Object.defineProperty(el, 'contextMenu', {
      get: function() {
        currentApp = app;

        $('apps-launch-command').label = app['name'];
        $('apps-options-command').canExecuteChange();

        var launchTypeEl;
        if (el.getAttribute('app-id') === app['id']) {
          launchTypeEl = el;
        } else {
          appLinkSel = 'a[app-id=' + app['id'] + ']';
          launchTypeEl = el.querySelector(appLinkSel);
        }

        var launchType = launchTypeEl.getAttribute('launch-type');
        var launchContainer = app['launch_container'];
        var isPanel = launchContainer == LaunchContainer.LAUNCH_PANEL;

        // Update the commands related to the launch type.
        var launchTypeIds = ['apps-launch-type-pinned',
                             'apps-launch-type-regular',
                             'apps-launch-type-fullscreen',
                             'apps-launch-type-window'];
        launchTypeIds.forEach(function(id) {
          var command = $(id);
          command.disabled = isPanel;
          command.checked = !isPanel &&
              launchType == command.getAttribute('launch-type');
        });

        return $('app-context-menu');
      }
    });
  }

  document.addEventListener('command', function(e) {
    if (!currentApp)
      return;

    var commandId = e.command.id;
    switch (commandId) {
      case 'apps-options-command':
        window.location = currentApp['options_url'];
        break;
      case 'apps-launch-command':
        launchApp(currentApp['id']);
        break;
      case 'apps-uninstall-command':
        chrome.send('uninstallApp', [currentApp['id']]);
        break;
      case 'apps-create-shortcut-command':
        chrome.send('createAppShortcut', [currentApp['id']]);
        break;
      case 'apps-launch-type-pinned':
      case 'apps-launch-type-regular':
      case 'apps-launch-type-fullscreen':
      case 'apps-launch-type-window':
        chrome.send('setLaunchType',
            [currentApp['id'],
             Number(e.command.getAttribute('launch-type'))]);
        break;
    }
  });

  document.addEventListener('canExecute', function(e) {
    switch (e.command.id) {
      case 'apps-options-command':
        e.canExecute = currentApp && currentApp['options_url'];
        break;
      case 'apps-launch-command':
        e.canExecute = true;
        break;
      case 'apps-uninstall-command':
        e.canExecute = !currentApp['can_uninstall'];
        break;
    }
  });

  // Moves the element at position |from| in array |arr| to position |to|.
  function arrayMove(arr, from, to) {
    var element = arr.splice(from, 1);
    arr.splice(to, 0, element[0]);
  }

  // The autoscroll rate during drag and drop, in px per second.
  var APP_AUTOSCROLL_RATE = 400;

  return {
    loaded: false,

    menu: $('apps-menu'),

    showPromo: false,

    detachWebstoreEntry: false,

    scrollMouseXY_: null,

    scrollListener_: null,

    // The list of app ids, in order, of each app in the launcher.
    data_: null,
    get data() { return this.data_; },
    set data(data) {
      this.data_ = data.map(function(app) {
        return app.id;
      });
      this.invalidate_();
    },

    dirty_: true,
    invalidate_: function() {
      this.dirty_ = true;
    },

    visible_: true,
    get visible() {
      return this.visible_;
    },
    set visible(visible) {
      this.visible_ = visible;
      this.invalidate_();
    },

    maybePingPromoSeen_: function() {
      if (promoHasBeenSeen || !this.showPromo || !isAppSectionMaximized())
        return;

      promoHasBeenSeen = true;
      chrome.send('promoSeen', []);
    },

    // DragAndDropDelegate

    dragContainer: $('apps-content'),
    transitionsDuration: 200,

    get dragItem() { return this.dragItem_; },
    set dragItem(dragItem) {
      if (this.dragItem_ != dragItem) {
        this.dragItem_ = dragItem;
        this.invalidate_();
      }
    },

    // The dimensions of each item in the app launcher.
    dimensions_: null,
    get dimensions() {
      if (this.dimensions_)
        return this.dimensions_;

      var width = 124;
      var height = 136;

      var marginWidth = 6;
      var marginHeight = 10;

      var borderWidth = 0;
      var borderHeight = 0;

      this.dimensions_ = {
        width: width + marginWidth + borderWidth,
        height: height + marginHeight + borderHeight
      };

      return this.dimensions_;
    },

    // Gets the item under the mouse event |e|. Returns null if there is no
    // item or if the item is not draggable.
    getItem: function(e) {
      var item = findAncestorByClass(e.target, 'app');

      // You can't drag the web store launcher.
      if (item && item.classList.contains('web-store-entry'))
        return null;

      return item;
    },

    // Returns true if |coordinates| point to a valid drop location. The
    // coordinates are relative to the drag container and the object should
    // have the 'x' and 'y' properties set.
    canDropOn: function(coordinates) {
      var cols = MAX_APPS_PER_ROW[layoutMode];
      var rows = Math.ceil(this.data.length / cols);

      var bottom = rows * this.dimensions.height;
      var right = cols * this.dimensions.width;

      if (coordinates.x >= right || coordinates.x < 0 ||
          coordinates.y >= bottom || coordinates.y < 0)
        return false;

      var position = this.getIndexAt_(coordinates);
      var appCount = this.data.length;

      if (!this.detachWebstoreEntry)
        appCount--;

      return position >= 0 && position < appCount;
    },

    setDragPlaceholder: function(coordinates) {
      var position = this.getIndexAt_(coordinates);
      var appId = this.dragItem.querySelector('a').getAttribute('app-id');
      var current = this.data.indexOf(appId);

      if (current == position || current < 0)
        return;

      arrayMove(this.data, current, position);
      this.invalidate_();
      this.layout();
    },

    getIndexAt_: function(coordinates) {
      var w = this.dimensions.width;
      var h = this.dimensions.height;

      var appsPerRow = MAX_APPS_PER_ROW[layoutMode];

      var row = Math.floor(coordinates.y / h);
      var col = Math.floor(coordinates.x / w);
      var index = appsPerRow * row + col;

      var appCount = this.data.length;
      var rows = Math.ceil(appCount / appsPerRow);

      // Rather than making the free space on the last row invalid, we
      // map it to the last valid position.
      if (index >= appCount && index < appsPerRow * rows)
        return appCount-1;

      return index;
    },

    scrollPage: function(xy) {
      var rect = this.dragContainer.getBoundingClientRect();

      // Here, we calculate the visible boundaries of the app launcher, which
      // are then used to determine when we should auto-scroll.
      var top = $('apps').getBoundingClientRect().bottom;
      var bottomFudge = 15; // Fudge factor due to a gradient mask.
      var bottom = top + maxiviewVisibleHeight - bottomFudge;
      var left = rect.left + window.scrollX;
      var right = Math.min(window.innerWidth, rect.left + rect.width);

      var dy = Math.min(0, xy.y - top) + Math.max(0, xy.y - bottom);
      var dx = Math.min(0, xy.x - left) + Math.max(0, xy.x - right);

      if (dx == 0 && dy == 0) {
        this.stopScroll_();
        return;
      }

      // If we scroll the page directly from this method, it may be choppy and
      // inconsistent. Instead, we loop using animation frames, and scroll at a
      // speed that's independent of how many times this method is called.
      this.scrollMouseXY_ = {dx: dx, dy: dy};

      if (!this.scrollListener_) {
        this.scrollListener_ = this.scrollImpl_.bind(this);
        this.scrollStep_();
      }
    },

    scrollStep_: function() {
      this.scrollStart_ = Date.now();
      window.webkitRequestAnimationFrame(this.scrollListener_);
    },

    scrollImpl_: function(time) {
      if (!appDragAndDrop.isDragging()) {
        this.stopScroll_();
        return;
      }

      if (!this.scrollMouseXY_)
        return;

      var step = time - this.scrollStart_;

      window.scrollBy(
          this.calcScroll_(this.scrollMouseXY_.dx, step),
          this.calcScroll_(this.scrollMouseXY_.dy, step));

      this.scrollStep_();
    },

    calcScroll_: function(delta, step) {
      if (delta == 0)
        return 0;

      // Increase the multiplier for every 50px the mouse is beyond the edge.
      var sign = delta > 0 ? 1 : -1;
      var scalar = APP_AUTOSCROLL_RATE * step / 1000;
      var multiplier = Math.floor(Math.abs(delta) / 50) + 1;

      return sign * scalar * multiplier;
    },

    stopScroll_: function() {
      this.scrollListener_ = null;
      this.scrollMouseXY_ = null;
    },

    saveDrag: function(draggedItem) {
      this.invalidate_();
      this.layout();

      var draggedAppId = draggedItem.querySelector('a').getAttribute('app-id');
      var appIds = this.data.filter(function(id) {
        return id != 'web-store-entry';
      });

      // Wait until the transitions are complete before notifying the browser.
      // Otherwise, the apps will be re-rendered while still transitioning.
      setTimeout(function() {
        chrome.send('reorderApps', [draggedAppId, appIds]);
      }, this.transitionsDuration + 10);
    },

    layout: function(options) {
      options = options || {};
      if (!this.dirty_ && options.force != true)
        return;

      try {
        var container = this.dragContainer;
        if (options.disableAnimations)
          container.setAttribute('launcher-animations', false);
        var d0 = Date.now();
        this.layoutImpl_();
        this.dirty_ = false;
        logEvent('apps.layout: ' + (Date.now() - d0));

      } finally {
        if (options.disableAnimations) {
          // We need to re-enable animations asynchronously, so that the
          // animations are still disabled for this layout update.
          setTimeout(function() {
            container.setAttribute('launcher-animations', true);
          }, 0);
        }
      }
    },

    layoutImpl_: function() {
      var apps = this.data || [];
      var rects = this.getLayoutRects_(apps.length);
      var appsContent = this.dragContainer;

      // Ping the PROMO_SEEN histogram only when the promo is maximized, and
      // maximum once per NTP load.
      this.maybePingPromoSeen_();

      if (!this.visible)
        return;

      for (var i = 0; i < apps.length; i++) {
        var app = appsContent.querySelector('[app-id='+apps[i]+']').parentNode;

        // If the node is being dragged, don't try to place it in the grid.
        if (app == this.dragItem)
          continue;

        app.style.left = rects[i].left + 'px';
        app.style.top = rects[i].top + 'px';
      }

      // We need to set the container's height manually because the apps use
      // absolute positioning.
      var rows = Math.ceil(apps.length / MAX_APPS_PER_ROW[layoutMode]);
      appsContent.style.height = (rows * this.dimensions.height) + 'px';
    },

    getLayoutRects_: function(appCount) {
      var availableWidth = this.dragContainer.offsetWidth;
      var rtl = isRtl();
      var rects = [];
      var w = this.dimensions.width;
      var h = this.dimensions.height;
      var appsPerRow = MAX_APPS_PER_ROW[layoutMode];

      for (var i = 0; i < appCount; i++) {
        var top = Math.floor(i / appsPerRow) * h;
        var left = (i % appsPerRow) * w;

        // Reflect the X axis if an RTL language is active.
        if (rtl)
          left = availableWidth - left - w;
        rects[i] = {left: left, top: top};
      }
      return rects;
    },

    get loadedImages() {
      return this.loadedImages_;
    },

    set loadedImages(value) {
      this.loadedImages_ = value;
      if (this.loadedImages_ == 0)
        return;

      // Each application icon is loaded asynchronously. Here, we display
      // the icons once they've all been loaded to make it look nicer.
      if (this.loadedImages_ == this.data.length) {
        this.showImages();
        return;
      }

      // We won't actually have the visible height until the sections have
      // been layed out.
      if (!maxiviewVisibleHeight)
        return;

      // If we know the visible height of the maxiview, then we can don't need
      // to wait for all the icons. Instead, we wait until the visible portion
      // have been loaded.
      var appsPerRow = MAX_APPS_PER_ROW[layoutMode];
      var rows = Math.ceil(maxiviewVisibleHeight / this.dimensions.height);
      var count = Math.min(appsPerRow * rows, this.data.length);
      if (this.loadedImages_ == count) {
        this.showImages();
        return;
      }
    },

    showImages: function() {
      $('apps-content').classList.add('visible');
      clearTimeout(this.imageTimer);
    },

    createElement: function(app) {
      var div = createElement(app);
      var a = div.firstChild;

      a.onclick = handleClick;
      a.ping = getAppPingUrl(
          'PING_BY_ID', this.showPromo, 'NTP_APPS_MAXIMIZED');
      a.style.backgroundImage = url(app['icon_big']);
      if (app.isNew) {
        div.setAttribute('new', 'new');
        // Delay changing the attribute a bit to let the page settle down a bit.
        setTimeout(function() {
          // Make sure the new icon is scrolled into view.
          document.body.scrollTop = document.body.scrollHeight;

          // This will trigger the 'bounce' animation defined in apps.css.
          div.setAttribute('new', 'installed');
        }, 500);
        div.addEventListener('webkitAnimationEnd', function(e) {
          div.removeAttribute('new');
        });
      }

      // CSS background images don't fire 'load' events, so we use an Image.
      var img = new Image();
      img.onload = function() { this.loadedImages++; }.bind(this);
      img.src = app['icon_big'];

      // User cannot change launch options or uninstall component extension.
      if (!app['is_component']) {
        var settingsButton = div.appendChild(new cr.ui.ContextMenuButton);
        settingsButton.className = 'app-settings';
        settingsButton.title = localStrings.getString('appsettings');
        addContextMenu(div, app);
      }

      return div;
    },

    createMiniviewElement: function(app) {
      var span = document.createElement('span');
      var a = span.appendChild(document.createElement('a'));

      a.setAttribute('app-id', app['id']);
      a.textContent = app['name'];
      a.href = app['launch_url'];
      a.onclick = handleClick;
      a.ping = getAppPingUrl(
          'PING_BY_ID', this.showPromo, 'NTP_APPS_COLLAPSED');
      a.style.backgroundImage = url(app['icon_small']);
      a.className = 'item';
      span.appendChild(a);

      // User cannot change launch options or uninstall component extension.
      if (!app['is_component']) {
        addContextMenu(span, app);
      }

      return span;
    },

    createClosedMenuElement: function(app) {
      var a = document.createElement('a');
      a.setAttribute('app-id', app['id']);
      a.textContent = app['name'];
      a.href = app['launch_url'];
      a.onclick = handleClick;
      a.ping = getAppPingUrl(
          'PING_BY_ID', this.showPromo, 'NTP_APPS_MENU');
      a.style.backgroundImage = url(app['icon_small']);
      a.className = 'item';

      // User cannot change launch options or uninstall component extension.
      if (!app['is_component']) {
        addContextMenu(a, app);
      }

      return a;
    },

    createWebStoreElement: function() {
      var elm = createElement({
        'id': 'web-store-entry',
        'name': localStrings.getString('web_store_title'),
        'launch_url': localStrings.getString('web_store_url')
      });
      elm.classList.add('web-store-entry');
      return elm;
    },

    createWebStoreMiniElement: function() {
      var span = document.createElement('span');
      span.appendChild(this.createWebStoreClosedMenuElement());
      return span;
    },

    createWebStoreClosedMenuElement: function() {
      var a = document.createElement('a');
      a.textContent = localStrings.getString('web_store_title');
      a.href = localStrings.getString('web_store_url');
      a.style.backgroundImage = url('chrome://theme/IDR_PRODUCT_LOGO_16');
      a.className = 'item';
      return a;
    }
  };
})();

// Enable drag and drop reordering of the app launcher.
var appDragAndDrop = new DragAndDropController(apps);
</script>

<script>
  cr.ui.decorate('menu', cr.ui.Menu);
  cr.ui.decorate('command', cr.ui.Command);
  cr.ui.decorate('button[menu]', cr.ui.MenuButton);

  if (cr.isChromeOS)
    $('closed-sections-bar').setAttribute('chromeos', true);

  initializeLogin();

  initializeSection('apps', MENU_APPS, Section.APPS);
  initializeSection('most-visited', MENU_THUMB, Section.THUMB);
  initializeSection('recently-closed', MENU_RECENT);

  updateSimpleSection('apps', Section.APPS);
  updateSimpleSection('most-visited', Section.THUMB);
  var appsInitiallyMenu = shownSections & MENU_APPS;
  var mostVisitedInitiallyMenu = shownSections & MENU_THUMB;
  var recentlyClosedInitiallyMenu = shownSections & MENU_RECENT;
  setSectionMenuMode('apps', Section.APPS, appsInitiallyMenu, MENU_APPS);
  setSectionMenuMode('most-visited', Section.THUMB, mostVisitedInitiallyMenu,
                     MENU_THUMB);
  setSectionMenuMode('recently-closed', undefined, recentlyClosedInitiallyMenu,
                     MENU_RECENT);

  layoutSections();
</script>
</html>
